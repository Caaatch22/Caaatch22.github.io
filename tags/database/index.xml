<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Database on Mingjie&#39;s Home</title>
    <link>https://caaatch22.github.io/tags/database/</link>
    <description>Recent content in Database on Mingjie&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 17 Jan 2023 23:45:12 +0000</lastBuildDate><atom:link href="https://caaatch22.github.io/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CMU15445-project3 Query Excution</title>
      <link>https://caaatch22.github.io/posts/cmu15445-project3-query-execution/</link>
      <pubDate>Tue, 17 Jan 2023 23:45:12 +0000</pubDate>
      
      <guid>https://caaatch22.github.io/posts/cmu15445-project3-query-execution/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了&lt;a href=&#34;https://15445.courses.cs.cmu.edu/fall2022/bustub/&#34;&gt;浏览器上的bustub&lt;/a&gt; ，方便和我们写的对比调试。你也可以使用 &lt;code&gt;explain&lt;/code&gt; 来查看他的优化策略与执行步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://caaatch22.github.io/img/busTub/query_excution/project-structure.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;上图是 bustub 的整体架构。&lt;/p&gt;
&lt;h3 id=&#34;parser&#34;&gt;Parser&lt;/h3&gt;
&lt;p&gt;sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个&lt;em&gt;抽象语法树(AST, Abstract Syntax Tree)&lt;/em&gt;。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。&lt;/p&gt;
&lt;h3 id=&#34;binder&#34;&gt;Binder&lt;/h3&gt;
&lt;p&gt;得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; table1.y, table2.x &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; table1 &lt;span style=&#34;color:#66d9ef&#34;&gt;INNER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN&lt;/span&gt; table2 &lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt; table1.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; table2.y;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;SELECT&lt;/code&gt; 和 &lt;code&gt;FROM&lt;/code&gt; 是关键字，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;table1&lt;/code&gt; 是标识符。我们可以使用 &lt;code&gt;explain&lt;/code&gt; 来看看 &lt;code&gt;binder&lt;/code&gt; 层（bustub-shell 未完成时也可以使用 explain）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; BINDER &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt;                                               
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; BoundSelec &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;                                        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   table&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;BoundJoin &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; type&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Inner, left&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;BoundBaseTableRef &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; table&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;table1, oid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;, right&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;BoundBaseTableRef &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; table&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;table2, oid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;, condition&lt;span style=&#34;color:#f92672&#34;&gt;=(&lt;/span&gt;table1.x&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;table2.y&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   columns&lt;span style=&#34;color:#f92672&#34;&gt;=[&lt;/span&gt;table1.y, table2.x&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;,                       
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   groupBy&lt;span style=&#34;color:#f92672&#34;&gt;=[]&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   having&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;,  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   where&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;,  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   limit&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   offset&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   order_by&lt;span style=&#34;color:#f92672&#34;&gt;=[]&lt;/span&gt;,                                 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   is_distinct&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;false,         
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ctes&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<blockquote>
<p>在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了<a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">浏览器上的bustub</a> ，方便和我们写的对比调试。你也可以使用 <code>explain</code> 来查看他的优化策略与执行步骤。</p>
</blockquote>
<p>这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。</p>
<p><img loading="lazy" src="/img/busTub/query_excution/project-structure.png" alt=""  />
</p>
<p>上图是 bustub 的整体架构。</p>
<h3 id="parser">Parser</h3>
<p>sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个<em>抽象语法树(AST, Abstract Syntax Tree)</em>。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。</p>
<h3 id="binder">Binder</h3>
<p>得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> table1.y, table2.x <span style="color:#66d9ef">FROM</span> table1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> table2 <span style="color:#66d9ef">ON</span> table1.x <span style="color:#f92672">=</span> table2.y;
</span></span></code></pre></div><p>其中 <code>SELECT</code> 和 <code>FROM</code> 是关键字，<code>x</code> 和 <code>table1</code> 是标识符。我们可以使用 <code>explain</code> 来看看 <code>binder</code> 层（bustub-shell 未完成时也可以使用 explain）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#f92672">===</span> BINDER <span style="color:#f92672">===</span>                                               
</span></span><span style="display:flex;"><span> BoundSelec <span style="color:#f92672">{</span>                                        
</span></span><span style="display:flex;"><span>   table<span style="color:#f92672">=</span>BoundJoin <span style="color:#f92672">{</span> type<span style="color:#f92672">=</span>Inner, left<span style="color:#f92672">=</span>BoundBaseTableRef <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table1, oid<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span> <span style="color:#f92672">}</span>, right<span style="color:#f92672">=</span>BoundBaseTableRef <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table2, oid<span style="color:#f92672">=</span><span style="color:#ae81ff">26</span> <span style="color:#f92672">}</span>, condition<span style="color:#f92672">=(</span>table1.x<span style="color:#f92672">=</span>table2.y<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>, 
</span></span><span style="display:flex;"><span>   columns<span style="color:#f92672">=[</span>table1.y, table2.x<span style="color:#f92672">]</span>,                       
</span></span><span style="display:flex;"><span>   groupBy<span style="color:#f92672">=[]</span>,
</span></span><span style="display:flex;"><span>   having<span style="color:#f92672">=</span>,  
</span></span><span style="display:flex;"><span>   where<span style="color:#f92672">=</span>,  
</span></span><span style="display:flex;"><span>   limit<span style="color:#f92672">=</span>, 
</span></span><span style="display:flex;"><span>   offset<span style="color:#f92672">=</span>,
</span></span><span style="display:flex;"><span>   order_by<span style="color:#f92672">=[]</span>,                                 
</span></span><span style="display:flex;"><span>   is_distinct<span style="color:#f92672">=</span>false,         
</span></span><span style="display:flex;"><span>   ctes<span style="color:#f92672">=</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。</p>
<h3 id="planner">Planner</h3>
<p>得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。查询计划也是一棵树的形式。例如这条 sql：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> table1.y, table2.x <span style="color:#66d9ef">FROM</span> table1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> table2 <span style="color:#66d9ef">ON</span> t1.x <span style="color:#f92672">=</span> t2.y;
</span></span></code></pre></div><p>查看 explain：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#f92672">===</span> PLANNER <span style="color:#f92672">===</span>
</span></span><span style="display:flex;"><span> Projection <span style="color:#f92672">{</span> exprs<span style="color:#f92672">=[</span><span style="color:#75715e">#0.1, #0.2] } | (table1.y:INTEGER, table2.x:INTEGER)                                                                                            </span>
</span></span><span style="display:flex;"><span>   NestedLoopJoin <span style="color:#f92672">{</span> type<span style="color:#f92672">=</span>Inner, predicate<span style="color:#f92672">=(</span><span style="color:#75715e">#0.0=#1.1) } | (table1.x:INTEGER, table1.y:INTEGER, table2.x:INTEGER, table2.y:INTEGER)                                   </span>
</span></span><span style="display:flex;"><span>     SeqScan <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table1 <span style="color:#f92672">}</span> | <span style="color:#f92672">(</span>table1.x:INTEGER, table1.y:INTEGER<span style="color:#f92672">)</span>                                                                                                 
</span></span><span style="display:flex;"><span>     SeqScan <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table2 <span style="color:#f92672">}</span> | <span style="color:#f92672">(</span>table2.x:INTEGER, table2.y:INTEGER<span style="color:#f92672">)</span> 
</span></span></code></pre></div><p>上面的解释其实是树型的，如下图：
<img loading="lazy" src="/img/busTub/query_excution/planner-tree.png" alt=""  />

查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。</p>
<h3 id="optimizer">Optimizer</h3>
<p>生成查询计划后
由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化，生成优化过后的最终查询计划。Optimizer 主要有两种实现方式：</p>
<ul>
<li>Rule-based.
<ul>
<li>通过自动重写查询来避免效率低的方法。例如我们在 Task 3 中将要实现的，将 <code>Limit + Sort</code> 合并为 <code>TopN</code>。</li>
<li>这种 Optimizer 不需要知道数据的具体内容，仅是根据预先定义好的规则修改 <code>Plan Node</code>。</li>
</ul>
</li>
<li>Cost-based.
<ul>
<li>用某种模型来预估执行计划的时间，这就需要存很多跟数据相关的数据</li>
<li>通过对不同模型的 cost 比较选出执行 cost 最小的。</li>
<li>这也会造成一些额外开销 （运行这个cost model）</li>
</ul>
</li>
</ul>
<p>Bustub 的 Optimizer 采用第一种实现方式。</p>
<blockquote>
<p>一般来说，Planner 生成的是 Logical Plan Node，代表抽象的 Plan。Optimizer 则生成 Physical Plan Node，代表具体执行的 Plan。例如是 Join。在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。</p>
</blockquote>
<h3 id="executor">Executor</h3>
<p>在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了。算子也是我们在 Project 3 中需要实现的主要内容。生成算子的步骤很简单，遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor。算子的执行模型也大致分为三种：</p>
<ol>
<li>
<p>Iterator/Pipeline Model(volcano model)。每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。火山模型一次调用只向下层算子请求一条数据，占用内存较小，但函数调用开销大。 <img loading="lazy" src="/img/busTub/query_excution/iterator-model.png" alt=""  />
</p>
</li>
<li>
<p>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高，但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</p>
</li>
<li>
<p>Vectorized/Batch Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库采用这种模型。</p>
</li>
</ol>
<p>Bustub 采用 Iterator Model。</p>
<h2 id="metadata">Metadata</h2>
<p>上面介绍了 sql语句执行过程，足以让我们对整个执行引擎有大体了解。但是我在做这个 lab 时候还是有很多困惑的地方。最后是迷迷糊糊的写完了才整理了下。大体上的信息包括在下图中：
<img loading="lazy" src="/img/busTub/query_excution/table-matedata.png" alt=""  />

（图片改自<a href="https://blog.eleven.wiki/posts/cmu15-445-project3-query-execution/">这篇博客</a>）</p>
<h2 id="task-1---access-method-executors">Task #1 - Access Method Executors</h2>
<h3 id="seqscan">SeqScan</h3>
<p>实现比较简单，获取 table_iter 直接遍历即可。这里说说这个<code>plan_-&gt;filter_predicate_</code>， 他是一个<code>AbstractExpressionRef</code>，而一个<code>AbstractExpression</code>意思是一个 <em>表达式</em> ，他里面最重要的两个函数是 <code>Evaluate(const Tuple *tuple, const Schema &amp;schema)</code>和 <code>EvaluateJoin(const Tuple *left_tuple, const Schema &amp;left_schema, const Tuple *right_tuple, const Schema &amp;right_schema)</code>，主要就是用来做 filter 的。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> table1 <span style="color:#66d9ef">where</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>如果任何优化都没有，那么上述语句可以解析为两层：</p>
<ol>
<li>从 table1 中选出所有的 tuple。</li>
<li>选出 x = 1的 tuple。相当于底下的 seqscan 结点会将所有 tuple 发到上一层，然后上一层再做一次 filter。但是我们通过谓词下推，可以在seqscan 时候就通过 filter_predicate_ 将需要的过滤出来，不需要的不用发给上一层。（当然，这个例子不太准确。在这个情况下本来就是一次搞定的，总之是在复杂的时候可以把谓词下推）。
这个 Evaluate 返回一个 <code>Value</code>，实际上如果做filter应该返回 boolean，所以需要通过<code>filter_predicate_-&gt;Evaluate(tuple, table_info_-&gt;schema_).GetAs&lt;bool&gt;()</code>转化一下。
另外，seqscan 实际上不会用到 filter_predicate。后面遇到需要 predicate 的地方会再强调。</li>
</ol>
<h3 id="insert--delete">Insert &amp; Delete</h3>
<p>这两个算子是唯二的写算子（实际上后面的优化过程中需要实现一个 update算子）。</p>
<p>我们先看下这两个算子的行为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>bustub<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span> (<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;🥰&#39;</span>, <span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;🥰🥰&#39;</span>, <span style="color:#ae81ff">11</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;🥰🥰🥰&#39;</span>, <span style="color:#ae81ff">12</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;🥰🥰🥰🥰&#39;</span>, <span style="color:#ae81ff">13</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;🥰🥰🥰🥰&#39;</span>, <span style="color:#ae81ff">14</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span> <span style="color:#66d9ef">output</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#75715e">-------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">|</span> __bustub_internal.insert_rows <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#75715e">-------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">|</span> <span style="color:#ae81ff">5</span>                             <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#75715e">-------------------------------+
</span></span></span></code></pre></div><p>这两个算子他们会一直 next，然后返回一次，返回的是插入/删除 tuple 的个数（所生成的tuple）。有点像 <code>pipeline breaker</code>，但是由于他们一定是顶层算子，所以好像不叫 <code>pipeline breaker</code>。</p>
<p>个人感觉这个返回个数的设计有点不是很合理，它一定要将个数转化成一个tuple返回。大概是这样的操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#f92672">*</span>tuple <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      Tuple(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span>(GetOutputSchema().GetColumnCount() <span style="color:#75715e">/* ColumnCount() should be one*/</span>, Value(TypeId<span style="color:#f92672">::</span>INTEGER, counter)),
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>GetOutputSchema());
</span></span></code></pre></div><p>另外需要注意的就是这些 增加/删除 tuple 时，对应的索引项也需要增加/删除。</p>
<h3 id="indexscan">IndexScan</h3>
<p>这个就简单了，在 Init() 时候保存 index_iter， next() 时直接调用再自增就可以。</p>
<h2 id="task-2---aggregation--join-executors">Task #2 - Aggregation &amp; Join Executors</h2>
<h3 id="aggregation">Aggregation</h3>
<p>aggregation 操作是一个 <code>pipeline breaker</code>。他会在 init 得到全部答案然后再 next 时一条一条返回。</p>
<p><code>SimpleAggregationHashTable</code> 维护一张哈希表，键为 <code>AggregateKey</code>，值为 <code>AggregateValue</code>，均为 <code>std::vector&lt;Value&gt;</code>。key 代表 group by 的字段的数组，value 则是需要 aggregate 的字段的数组。在下层算子传来一个 tuple 时，将 tuple 的 group by 字段和 aggregate 字段分别提取出来，调用 <code>InsertCombine()</code> 将 group by 和 aggregate 的映射关系存入 <code>SimpleAggregationHashTable</code>。若当前 hashmap 中没有 group by 的记录，则创建初值；若已有记录，则按 aggregate 规则逐一更新所有的 aggregate 字段，例如取 max/min，求 sum 等等。例如下面这条 sql：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">min</span>(t.z), <span style="color:#66d9ef">max</span>(t.z), <span style="color:#66d9ef">sum</span>(t.z) <span style="color:#66d9ef">FROM</span> t <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> t.x, t.y;
</span></span></code></pre></div><p>group by（AggregateKey）为 {t.x, t.y}，aggregate（AggregateValue）为 {t.z, t.z, t.z}。aggregate 规则为 {min, max, sum}。</p>
<p>需要额外注意 <code>count(column)</code> 和 <code>count(*)</code> 的区别，以及对空值的处理。</p>
<p>在 Init() 中计算出整张 hashmap 后，在 Next() 中直接利用 hashmap iterator 将结果依次取出。这里的输出形式有点奇怪，需要这样的输出：
<img loading="lazy" src="/img/busTub/query_excution/aggregate-return.png" alt=""  />
</p>
<p><code>schema</code> 已经在 <code>GetOutputSchema()</code> 中准备好了。</p>
<h3 id="nestedloopjoin">NestedLoopJoin</h3>
<p>我的实现比较 tricky。我在 init 时候直接把下层算子（left_executor和right_executor）所有的tuple都得到了（相当于当作 pipeline breaker），保存在两张表中。再 next时候进行匹配。这里的 left-join 和 inner-join 是需要分开实现的，可以在网上查下left-join和inner-join的区别。
在这里判断左右两个 tuple 是否 match 就需要用到<code>plan_-&gt;Predicate().EvaluateJoin()</code>，同样要 <code>GetAs&lt;bool&gt;()</code>。</p>
<p>当我们得到一个 match 后，返回前记得<strong>保存上下文</strong>，例如，你可以保存 match 的 tuple 再左表中的下标和右表中的下标，这样下次调用 next 时候，就不用重新扫描一次。</p>
<h3 id="nestedindexjoin">NestedIndexJoin</h3>
<p>在进行 equi-join 时，如果发现 JOIN ON 右边的字段上建了 index，则 Optimizer 会将 NestedLoopJoin 优化为 NestedIndexJoin。具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p>
<h2 id="task-3---sort--limit-executors-and-top-n-optimization">Task #3 - Sort + Limit Executors and Top-N Optimization</h2>
<h3 id="sort">sort</h3>
<p>这个实验的 sort 无需进行外部排序，重载小于后就可以实现。就是比较的方式有点奇怪，可以类比以下写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>order_key.second<span style="color:#f92672">-&gt;</span>Evaluate(<span style="color:#f92672">&amp;</span>lhs, schema).CompareLessThan(order_key.second<span style="color:#f92672">-&gt;</span>Evaluate(<span style="color:#f92672">&amp;</span>rhs, schema))
</span></span></code></pre></div><h3 id="limit">limit</h3>
<p>简单，limit 限制在 <code>plan_-&gt;Getlimit()</code>里面。</p>
<h3 id="top-n-optimization-rule">Top-N Optimization Rule</h3>
<p>简单，优先队列重载小于（重载方式与 sort 相同），然后截取前 n 个。</p>
<h3 id="sort--limit-as-topn">Sort + Limit As TopN</h3>
<p>这是 Project 3 里最后一个必做的小问，也是唯一一个 Optimizer ，将 Sort + Limit 优化为 TopN。先看看 Optimizer 是如何执行优化规则的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> Optimizer<span style="color:#f92672">::</span>OptimizeCustom(<span style="color:#66d9ef">const</span> AbstractPlanNodeRef <span style="color:#f92672">&amp;</span>plan) <span style="color:#f92672">-&gt;</span> AbstractPlanNodeRef {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> plan;
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeMergeProjection(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeMergeFilterNLJ(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeNLJAsIndexJoin(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeNLJAsHashJoin(p);  <span style="color:#75715e">// Enable this rule after you have implemented hash join.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  p <span style="color:#f92672">=</span> OptimizeOrderByAsIndexScan(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeSortLimitAsTopN(p);  <span style="color:#75715e">// what we should add
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到，让未经优化的原始 plan 树依次经历多条规则，来生成优化过的 plan。我们的任务就是新增一条规则。看看其他规则是怎么实现的，例如 NLJAsIndexJoin：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> Optimizer<span style="color:#f92672">::</span>OptimizeNLJAsIndexJoin(<span style="color:#66d9ef">const</span> AbstractPlanNodeRef <span style="color:#f92672">&amp;</span>plan) <span style="color:#f92672">-&gt;</span> AbstractPlanNodeRef {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AbstractPlanNodeRef<span style="color:#f92672">&gt;</span> children;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>child : plan<span style="color:#f92672">-&gt;</span>GetChildren()) {
</span></span><span style="display:flex;"><span>    children.emplace_back(OptimizeNLJAsIndexJoin(child));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> optimized_plan <span style="color:#f92672">=</span> plan<span style="color:#f92672">-&gt;</span>CloneWithChildren(std<span style="color:#f92672">::</span>move(children));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (optimized_plan<span style="color:#f92672">-&gt;</span>GetType() <span style="color:#f92672">==</span> PlanType<span style="color:#f92672">::</span>NestedLoopJoin) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// apply the rule and return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> optimized_plan;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到，实际上就是对 plan tree 进行后序遍历，自底向上地适用规则，改写节点。遍历到某个节点时，通过 if 语句来判断当前节点的类型是否符合我们要优化的类型，若符合则进行优化。</p>
<p>大致了解如何对 plan 进行优化后，就可以开始写我们的优化规则了。需要特别注意的是，能优化为一个 TopN 算子的形式是，上层节点为 Limit，下层节点为 Sort，不能反过来。同样，我们对 plan tree 进行后续遍历，在遇到 Limit 时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN。还是比较好实现的，只是代码看起来可能有点复杂。</p>
<h2 id="leaderboard-task">Leaderboard Task</h2>
<p>暂时还没写，有空了补补</p>
<p><strong>AC!</strong>
<img loading="lazy" src="/img/busTub/query_excution/p3-result.png" alt=""  />
</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">bustub on web</a></li>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li>
<li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li>
<li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>CMU15445-project2 Concurrent B&#43; tree</title>
      <link>https://caaatch22.github.io/posts/cmu15445-project2-concurrent-b-tree/</link>
      <pubDate>Tue, 27 Dec 2022 23:45:12 +0000</pubDate>
      
      <guid>https://caaatch22.github.io/posts/cmu15445-project2-concurrent-b-tree/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这个实验应该是最难的一个实验了。。。（感觉和Project 4 —— Transaction实现的难度差不多） 另外，2022fall版本的B+ tree更是变态，因为几乎没有给任何内部的API，让人无从下手。建议到 Github repo 里找到20年的，我基本是根据里面定义的函数来实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实验材料&lt;del&gt;贴心的&lt;/del&gt;为你分成了两个检查点，四个小任务。&lt;/p&gt;
&lt;p&gt;Checkpoint #1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Task #1 - B+Tree Pages&lt;/li&gt;
&lt;li&gt;Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Checkpoint #2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Task #3 - Index Iterator&lt;/li&gt;
&lt;li&gt;Task #4 - Concurrent Index&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;task-1---btree-pages&#34;&gt;Task #1 - B+Tree Pages&lt;/h2&gt;
&lt;p&gt;第一个任务算是热身，主要是搞清楚 B+ 树的一些类之间的关系。
我们知道，数据库中的索引也是数据，同样以 page 的形式被组织。我们先来看看要完成的这些类之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://caaatch22.github.io/img/busTub/B-tree/B-tree-page-relation.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;B+ tree internal page&lt;/code&gt; 与 &lt;code&gt;B + tree leaf page&lt;/code&gt; 都继承自&lt;code&gt;B + tree page&lt;/code&gt;，&lt;code&gt;B + tree page&lt;/code&gt; 中定义了 B+ 树每个结点的一些信息。而B + Tree 这个类则是Checkpoint 1的主要对象，它对&lt;code&gt;internal page&lt;/code&gt; 以及 &lt;code&gt;leaf page&lt;/code&gt; 进行管理，并对外开放接口。而在内存中，internal page 与 leaf page 都属于 page 的一部分，关系如下图所示。他们就是 &lt;code&gt;page&lt;/code&gt; 中的 data 部分。因此，每次
从 buffer pool manager 得到一个 page 后，若是将他们用作 B+树的结点，则需要对这个 data 进行&lt;strong&gt;释义&lt;/strong&gt;，也就是将他强制转化为internal page 或者 leaf page。这在 C++ 中通过 &lt;a href=&#34;https://en.cppreference.com/w/cpp/language/reinterpret_cast&#34;&gt;&lt;strong&gt;reinterpret_cast&lt;/strong&gt;&lt;/a&gt; 完成。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<blockquote>
<p>这个实验应该是最难的一个实验了。。。（感觉和Project 4 —— Transaction实现的难度差不多） 另外，2022fall版本的B+ tree更是变态，因为几乎没有给任何内部的API，让人无从下手。建议到 Github repo 里找到20年的，我基本是根据里面定义的函数来实现的。</p>
</blockquote>
<p>实验材料<del>贴心的</del>为你分成了两个检查点，四个小任务。</p>
<p>Checkpoint #1</p>
<ul>
<li>Task #1 - B+Tree Pages</li>
<li>Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</li>
</ul>
<p>Checkpoint #2</p>
<ul>
<li>Task #3 - Index Iterator</li>
<li>Task #4 - Concurrent Index</li>
</ul>
<h2 id="task-1---btree-pages">Task #1 - B+Tree Pages</h2>
<p>第一个任务算是热身，主要是搞清楚 B+ 树的一些类之间的关系。
我们知道，数据库中的索引也是数据，同样以 page 的形式被组织。我们先来看看要完成的这些类之间的关系。</p>
<p><img loading="lazy" src="/img/busTub/B-tree/B-tree-page-relation.png" alt=""  />
</p>
<p><code>B+ tree internal page</code> 与 <code>B + tree leaf page</code> 都继承自<code>B + tree page</code>，<code>B + tree page</code> 中定义了 B+ 树每个结点的一些信息。而B + Tree 这个类则是Checkpoint 1的主要对象，它对<code>internal page</code> 以及 <code>leaf page</code> 进行管理，并对外开放接口。而在内存中，internal page 与 leaf page 都属于 page 的一部分，关系如下图所示。他们就是 <code>page</code> 中的 data 部分。因此，每次
从 buffer pool manager 得到一个 page 后，若是将他们用作 B+树的结点，则需要对这个 data 进行<strong>释义</strong>，也就是将他强制转化为internal page 或者 leaf page。这在 C++ 中通过 <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast"><strong>reinterpret_cast</strong></a> 完成。</p>
<p><img loading="lazy" src="/img/busTub/B-tree/pages.png" alt=""  />
</p>
<p>然后就是一些getter，setter的实现。这个 <code>MappingType array[1]</code> 是个奇技淫巧叫<a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>，由于整个internal page的大小是确定的（由data[buffer_size]转义而来），这个 array 的大小就是去掉 header后的大小。（另外，实际上应该写作 <code>MappingType array[0]</code>，不然过不了 check-format）。</p>
<h2 id="task-2---btree-data-structure-insertion-deletion-point-search">Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</h2>
<p>这个任务就是本实验最为核心的一点——实现基于磁盘的 B+ 树数据结构。这里不会详细展开，因为过于复杂且很多细节<del>因为忘光了</del>。给个<a href="https://github.com/cmu-db/bustub/blob/1cc1bb2f7b0746c67a974c0554c843ac35519315/src/storage/index/b_plus_tree.cpp">20年fall</a>的B+ tree，功能是一样的，但是提供了完善的内部接口，照着这个和书上完成要清晰不少。</p>
<h3 id="debug">debug</h3>
<p>TAs准备了b_plus_tree_printer工具，并且已经准备的Draw/ToString方法，善用它们将B+树可视化，更好的观察插入、删除行为是否正确。 示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> step <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;     
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> key : keys) {       
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int64_t</span> value <span style="color:#f92672">=</span> key <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFF</span>;       
</span></span><span style="display:flex;"><span>  rid.Set(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int32_t</span><span style="color:#f92672">&gt;</span>(key <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span>), value);       
</span></span><span style="display:flex;"><span>  index_key.SetFromInteger(key);       
</span></span><span style="display:flex;"><span>  tree.Insert(index_key, rid, transaction);       
</span></span><span style="display:flex;"><span>  tree.Draw(bpm, <span style="color:#e6db74">&#34;xxxxx/InsertTest_step&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(step<span style="color:#f92672">++</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_insert&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(key) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.dot&#34;</span>);     
</span></span><span style="display:flex;"><span>}     
</span></span><span style="display:flex;"><span>tree.Draw(bpm, <span style="color:#e6db74">&#34;xxxxxx/InsertTest_step.dot&#34;</span>);
</span></span></code></pre></div><p>得到生成的文件后打开，可以和<a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">reference solution</a>比较。</p>
<h2 id="task-3---index-iterator">Task #3 - Index Iterator</h2>
<p>我想重点说下这个 iterator 的实现，因为在这个实验中，我调了最久的 bug 就出现在这个子任务中。（实际上已经过了lab-2的评测已经过了，是在 lab3评测时发生锁资源的问题）</p>
<p>记得哪个大佬说过，如何看一个人的 C++ 水平，从他写的构造函数就可以略窥一二。C++ 的构造函数属实花里胡哨，<code>copy ctor</code>, <code>copy assignment</code>, <code>move ctor</code>, <code>move assignment</code> , 再加上 <code>initializatier list</code>以及模板&hellip; 哪些要写，哪些应当禁止都是门学问。</p>
<p>根据 <a href="https://zh.wikipedia.org/zh-hans/RAII">RAII</a> 的思想，C++ 的 contructor（配合dtor）肩负了管理资源的作用。这个资源不知包括内存资源，还包括锁资源等等。而对于 Index iterator 来说，每个 iterator 都带有一个隐含的读属性，并发读要求对 page 上读锁，但是我们的 iterator 又不直接管理 page 资源，需要通过传入指针（用shared_ptr最好）的方式对 page 进行操作。</p>
<p>我们来看这个例子 在</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>index_iter_ <span style="color:#f92672">=</span> GetBPlusTreeIndex()<span style="color:#f92672">-&gt;</span>GetBeginIterator();
</span></span></code></pre></div><p>这是lab3中用到索引迭代器的一个地方的代码。注意到这会产生一个临时对象，并把它赋值给 index_iter_。如果我们在析构的时候释放了对应 page 的锁而没有写<code>copy assignment</code>，编译器生成的assignment是不会在赋值的时候为page上锁的。</p>
<p>这个bug归根结底在于，我们的迭代器应该是 <strong>值语义(value semantic)</strong> 的（至少对于锁资源来讲）</p>
<p>我们用 <strong>copy and swap</strong> idiom 来解决这个问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>INDEX_TEMPLATE_ARGUMENTS
</span></span><span style="display:flex;"><span>INDEXITERATOR_TYPE<span style="color:#f92672">::</span>IndexIterator(BufferPoolManager <span style="color:#f92672">*</span>bpm, Page <span style="color:#f92672">*</span>page, <span style="color:#66d9ef">int</span> index, page_id_t page_id)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> bpm_(bpm), page_(page), index_(index), page_id_(page_id) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (page <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>    leaf_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>LeafPage <span style="color:#f92672">*&gt;</span>(page<span style="color:#f92672">-&gt;</span>GetData());
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    leaf_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>INDEX_TEMPLATE_ARGUMENTS
</span></span><span style="display:flex;"><span>INDEXITERATOR_TYPE<span style="color:#f92672">::</span>IndexIterator(<span style="color:#66d9ef">const</span> IndexIterator <span style="color:#f92672">&amp;</span>rhs)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> bpm_(rhs.bpm_), index_(rhs.index_), page_id_(rhs.page_id_), leaf_(rhs.leaf_) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (page_id_ <span style="color:#f92672">!=</span> INVALID_PAGE_ID) {
</span></span><span style="display:flex;"><span>    page_ <span style="color:#f92672">=</span> bpm_<span style="color:#f92672">-&gt;</span>FetchPage(page_id_);
</span></span><span style="display:flex;"><span>    page_<span style="color:#f92672">-&gt;</span>RLatch();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>INDEX_TEMPLATE_ARGUMENTS
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> INDEXITERATOR_TYPE<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(IndexIterator rhs) <span style="color:#f92672">-&gt;</span> IndexIterator <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>  Swap(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, rhs);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Swap</span>(IndexIterator <span style="color:#f92672">&amp;</span>lhs, IndexIterator <span style="color:#f92672">&amp;</span>rhs) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>swap;
</span></span><span style="display:flex;"><span>  swap(lhs.bpm_, rhs.bpm_);
</span></span><span style="display:flex;"><span>  swap(lhs.page_, rhs.page_);
</span></span><span style="display:flex;"><span>  swap(lhs.index_, rhs.index_);
</span></span><span style="display:flex;"><span>  swap(lhs.page_id_, rhs.page_id_);
</span></span><span style="display:flex;"><span>  swap(lhs.leaf_, rhs.leaf_);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="task-4---index-iterator">Task #4 - Index Iterator</h2>
<p>这是并发 B+ 树的重点。我们要使此前实现的 B+ 树支持并发的 Search/Insert/Delete 操作。整棵树一把锁逻辑上来说当然是可以的，但性能肯定不行，我们需要更加细粒度的锁管理。在这里，我们会使用一种特殊的加锁方式，叫做 latch crabbing。顾名思义，就像螃蟹一样，移动一只脚，放下，移动另一只脚，再放下。基本思想是：</p>
<ol>
<li>先锁住 parent page，</li>
<li>再锁住 child page，</li>
<li>假设 child page 是安全的，则释放 parent page 的锁。安全指当前 page 在当前操作下一定不会发生 split/steal/merge。同时，安全对不同操作的定义是不同的，Search 时，任何节点都安全；Insert 时，判断 max size；Delete 时，判断 min size。</li>
</ol>
<p>这么做的原因和正确性还是比较明显的。当 page 为安全的时候，当前操作仅可能改变此 page 及其 child page 的值，因此可以提前释放掉其祖先的锁来提高并发性能。</p>
<p>最后是AC截图：</p>
<p><img loading="lazy" src="/img/busTub/B-tree/p2-result.png" alt=""  />
</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li>
<li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li>
<li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>CMU15445-project1 Buffer Pool Manager</title>
      <link>https://caaatch22.github.io/posts/cmu15445-project1-buffer-pool-manager/</link>
      <pubDate>Thu, 22 Dec 2022 15:37:34 +0000</pubDate>
      
      <guid>https://caaatch22.github.io/posts/cmu15445-project1-buffer-pool-manager/</guid>
      <description>&lt;h1 id=&#34;buffer-pool-manager&#34;&gt;Buffer Pool Manager&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;cmu15445 是一门关于数据库管理系统（DBMS）设计与实现的经典公开课，是很多dba和内核开发人员的入门课程。开课教授Andy Pavlo 非常风趣幽默，他有自己上课的DJ，他曾在浴缸里录课，且时常语出惊人。这门课的实验项目BusTub非常有挑战性，并对所有人开放评测资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;BusTub是一个面向磁盘的 DBMS(Database Management System)。由于磁盘上的数据不支持字节粒度的访问，这就需要一个管理页的中间层，而 Andy 坚持&lt;a href=&#34;https://db.cs.cmu.edu/mmap-cidr2022/&#34;&gt;&amp;ldquo;The OS is not your friend&amp;rdquo;&lt;/a&gt;， 反对使用 mmap 进行页操作，因此实验一的目标便在于通过实现 Buffer Pool Manager 主动管理磁盘中的页（page）在内存中的缓存，从而，最小化磁盘访问次数（时间上）、最大化相关数据连续（空间上）。&lt;/p&gt;
&lt;p&gt;这次实验有三个子任务，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Task #1: Extendible Hash Table&lt;/li&gt;
&lt;li&gt;Task #2: LRU-K Replacer&lt;/li&gt;
&lt;li&gt;Task #3: Buffer Pool Manager Instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可拓展哈希表是这个是实验中相对独立的模块。这里不会讲它的细节，后面的两个任务中需要用到哈希表的地方我直接用std::unordered_map替代，而且效率还更高。应该是因为 Extendible Hash Table 要求线程安全，为了方便在我在每个函数入口都加了大锁。
想要 Extendible Hash Table 具体细节的可以看这个&lt;a href=&#34;https://www.bilibili.com/video/BV1nV4y1N7LM/?spm_id_from=333.788&amp;amp;vd_source=11c680307875dda5d5b5c13fca2e5c57&#34;&gt;b站视频&lt;/a&gt;。关于它的优化，我想可以进行更细粒度的锁管理甚至写一个无锁(lockfree)的哈希表。&lt;/p&gt;
&lt;h2 id=&#34;buffer-pool-manager-1&#34;&gt;Buffer Pool Manager&lt;/h2&gt;
&lt;p&gt;在后两个实验开始之前，我建议先将Task #2和Task #3的&lt;a href=&#34;https://15445.courses.cs.cmu.edu/fall2022/project1/&#34;&gt;实验材料&lt;/a&gt;完整的看完在开始写代码。因为 &lt;code&gt;replacer&lt;/code&gt; 和 &lt;code&gt;buffer pool manager&lt;/code&gt; 有较大程度的耦合。很多API设计需要对照两个组件才能知道自己应该维护的数据与功能的边界。为了更符合直觉，我会先阐述 &lt;code&gt;buffer pool manager&lt;/code&gt; 的设计，同时会穿插着 &lt;code&gt;LRU-k&lt;/code&gt; 的API什么时候，在哪用。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="buffer-pool-manager">Buffer Pool Manager</h1>
<blockquote>
<p>cmu15445 是一门关于数据库管理系统（DBMS）设计与实现的经典公开课，是很多dba和内核开发人员的入门课程。开课教授Andy Pavlo 非常风趣幽默，他有自己上课的DJ，他曾在浴缸里录课，且时常语出惊人。这门课的实验项目BusTub非常有挑战性，并对所有人开放评测资源。</p>
</blockquote>
<h2 id="overview">Overview</h2>
<p>BusTub是一个面向磁盘的 DBMS(Database Management System)。由于磁盘上的数据不支持字节粒度的访问，这就需要一个管理页的中间层，而 Andy 坚持<a href="https://db.cs.cmu.edu/mmap-cidr2022/">&ldquo;The OS is not your friend&rdquo;</a>， 反对使用 mmap 进行页操作，因此实验一的目标便在于通过实现 Buffer Pool Manager 主动管理磁盘中的页（page）在内存中的缓存，从而，最小化磁盘访问次数（时间上）、最大化相关数据连续（空间上）。</p>
<p>这次实验有三个子任务，分别是</p>
<ul>
<li>Task #1: Extendible Hash Table</li>
<li>Task #2: LRU-K Replacer</li>
<li>Task #3: Buffer Pool Manager Instance</li>
</ul>
<p>可拓展哈希表是这个是实验中相对独立的模块。这里不会讲它的细节，后面的两个任务中需要用到哈希表的地方我直接用std::unordered_map替代，而且效率还更高。应该是因为 Extendible Hash Table 要求线程安全，为了方便在我在每个函数入口都加了大锁。
想要 Extendible Hash Table 具体细节的可以看这个<a href="https://www.bilibili.com/video/BV1nV4y1N7LM/?spm_id_from=333.788&amp;vd_source=11c680307875dda5d5b5c13fca2e5c57">b站视频</a>。关于它的优化，我想可以进行更细粒度的锁管理甚至写一个无锁(lockfree)的哈希表。</p>
<h2 id="buffer-pool-manager-1">Buffer Pool Manager</h2>
<p>在后两个实验开始之前，我建议先将Task #2和Task #3的<a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">实验材料</a>完整的看完在开始写代码。因为 <code>replacer</code> 和 <code>buffer pool manager</code> 有较大程度的耦合。很多API设计需要对照两个组件才能知道自己应该维护的数据与功能的边界。为了更符合直觉，我会先阐述 <code>buffer pool manager</code> 的设计，同时会穿插着 <code>LRU-k</code> 的API什么时候，在哪用。</p>
<p><strong>Buffer Pool Manager</strong> 维护的数据的基本单位为一段逻辑连续的字节数组，在磁盘上表现为<strong>页（page）</strong>，页内部结构有自己的一些结构（包括header, content等），在这个实验中我们只关心 <code>page_id_</code> (页的唯一标识)， <code>pin_conut_</code> 以及 <code>is_dirty_</code> 。对应在内存上，我们用 <strong>frame</strong> 这个词代表 <strong>框</strong>，就是装着某个物理页的框。在代码中其实就是buffer pool管理着一大片内存 <code>Page pages[pool_size_]</code>，但是 buffer pool 初始化时（资源获取时）我们得到的 pages 并不包含我们想要的页，它里面的数据是没有意义的，从而它是一个<em>空的框</em>。frame_id指的就是这个数组的下标。里面装的页有自己的<code>page_id</code>。另外，我们用一个哈希表<code>page_table_</code>保存从 页号(page id) 到 框号(frame_id) 的映射。</p>
<!-- raw HTML omitted -->
<p>管理帧的内存池大小一般来说是远小于磁盘的，因此在内存池满了后，再从磁盘加载新的页到内存池，需要某种替换策略（replacer）将一些不再使用的页踢出内存池以腾出空间。</p>
<p>buffer pool manager 的<strong>实现核心</strong>在于对所有 page 的状态的管理。每个page有四种状态：</p>
<ol>
<li><strong>Not Allocated(Not Exist):</strong> 我们将不存在的 page 也当作一种状态</li>
<li><strong>Allocated but Not in MEM:</strong> allocated 但是不存在于内存中（某一时刻内存装的 page 达到上线后被 evict 出内存）</li>
<li><strong>Unpinned and in MEM:</strong> 随时可能被 evict</li>
<li><strong>Pinned(definitely in MEM)</strong></li>
</ol>
<p><strong>这几种状态是互斥的</strong></p>
<p>待实现函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> BufferPoolManagerInstance<span style="color:#f92672">::</span>NewPgImp(page_id_t <span style="color:#f92672">*</span>page_id) <span style="color:#f92672">-&gt;</span> Page <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> BufferPoolManagerInstance<span style="color:#f92672">::</span>FetchPgImp(page_id_t page_id) <span style="color:#f92672">-&gt;</span> Page <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> BufferPoolManagerInstance<span style="color:#f92672">::</span>UnpinPgImp(page_id_t page_id, <span style="color:#66d9ef">bool</span> is_dirty) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> BufferPoolManagerInstance<span style="color:#f92672">::</span>DeletePgImp(page_id_t page_id) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span>
</span></span></code></pre></div><p>便是驱动状态机中上述状态发生改变的动作（action），（注意： <em>AllocatePage 和 DeallocatePage</em>不对外部公开） 状态机如下：</p>
<!-- raw HTML omitted -->
<p>每个函数声明处的注释已经非常详细的描述了函数行为了。以下列出一些我在做的时候容易困惑的点：</p>
<ul>
<li><code>page_table_</code>维护的只是在内存中的page的<code>page_id</code>到<code>frame_id</code>的映射。也就是说它不保存 <em>Allocated but not in MEM</em> 的 page（因为在磁盘上的page也没有一个到 <code>frame_id</code> 的映射）</li>
<li><code>Unpin</code> 操作并不一定会使 page 变成 <em>Unpinned and in MEM</em>，因为这只是这一个 <em>worker（一般来说是一个thread）</em> 对该 page 进行 unpin，其他线程可能也正在读取这个 page 的内容。 只有当 某次 Unpin 操作后，它的<code>pin_count_</code> 等于0时，才能让这个 page 变成 <code>evitable</code>的状态（在 replacer 中维护）</li>
<li><code>AllocatePage</code> 只在 <code>NewPage</code>中用到，<code>DeallocatePage</code> 只在 <code>DeletePage</code> 中用到</li>
<li><code>Unpin</code> 的 <code>is_dirty</code> 参数为 true 时，将这个 page 的<code>is_dirty_</code>设置为true， <strong>而当参数为false时，不可以将page的 is_dirty_ 设置为false! 而应该保持原 dirty 状态不变</strong> 因为 <code>is_dirty</code> 参数表示的只是这个线程是否对这个 page 有修改操作。（这个点害我debug了好久）</li>
</ul>
<p>现在我们借助 replacer 的 API 来理解一下每个 page 在他的生命周期中需要被维护什么内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 发生在NewPage和FetchPage时，且free_list_为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param[out] frame_id id of frame that is evicted.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">Evict</span>(frame_id_t <span style="color:#f92672">*</span>frame_id) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 发生在NewPage和FetchPage中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RecordAccess</span>(frame_id_t frame_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 在NewPage和FetchPage set_evictable 设置为 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  在 Unpin后，pin_count为0下 set_evictable 设置为 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetEvictable</span>(frame_id_t frame_id, <span style="color:#66d9ef">bool</span> set_evictable);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 发生在DeletePage中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Remove</span>(frame_id_t frame_id);
</span></span></code></pre></div><p>以 FetchPageImpl 为例强调下一些实现的细节。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> BufferPoolManagerInstance<span style="color:#f92672">::</span>FetchPgImp(page_id_t page_id) <span style="color:#f92672">-&gt;</span> Page <span style="color:#f92672">*</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 1. 上锁！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 2. 查看 page 是否在 page_table_ 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.1 若在 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   2.1.2 得到frame_id, 目标为pages[frame_id]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   2.1.3 目标内部的pin_count状态维护
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   2.1.4 replacer 维护recordAccess和setEvictable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   2.1.5 返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 2.2 若不在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.1 找一个可用的 frame (先从free list里找，没有则让 replacer evict一个)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.2 清空frame_id中原来的信息 （包括old_page dirty的话写回磁盘）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.3 维护 page_table (删除这个frame_id对应的old_page的信息)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.4 设置新的page_id，从磁盘中读入，并维护新 page 内部信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.5 维护 replacer 相关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.6 维护page_table 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  2.2.7 返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="lru-k-replacer">LRU-K Replacer</h2>
<p><strong>LRU-k evict policy</strong> 是让访问次数未到 k 的结点会被优先 evict 出去（这么做或许是为了防止一些微小的 <em>扰动访问</em> 污染了原来经常访问的区域），然后对于访问次数到达 k 次的结点则按照最近访问时间（或逻辑上的时间戳）最久远的被 evict。（实际上按照原始论文和 slides 上的意思应该是最近访问时间和第前 k 次访问时间<strong>之差</strong>相差最大的被 evict，但是按照前面的方法也过了。。。）</p>
<ul>
<li><a href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf">LRU-k的原始论文</a></li>
<li><a href="https://leetcode.cn/problems/lru-cache/">leetcode上的lru算法</a>，不熟悉的可以先试试</li>
</ul>
<p>针对 LRU-k 算法，我实现了两种方法，简单说一下思路。</p>
<h3 id="方法一">方法一</h3>
<p>维护两个链表，一个存未到 k 次访问的<code>frame_id</code>,另一个存已到（或超过）k 次访问的 <code>frame_id</code>，我们分别将其叫做 <code>history_list</code>以及<code>cache_list</code>。</p>
<p>同时维护一个从<code>frame_id</code>到 <code>FrameEntry</code>的哈希表，这个<code>FrameEntry</code>保存了<code>hit_count</code>，<code>evictible</code>以及一个list&lt;frame_id_t&gt;的迭代器。</p>
<ul>
<li><strong>Evict:</strong> 若 hist_list 非空，找到第一个 evictable 的 frame 将其踢出，否则找cache_list 中第一个evictable 的 frame。</li>
<li><strong>RecordAccess(frame_id):</strong>  通过 <code>FrameEntry</code> 查看 hit_count （1）若他是第一次访问，则将其放在 history_list 尾部，注意，同时还要维护这个 frame_id 在FrameEntry 中的迭代器 。（2）若 new_count == k 则在history_list中删去这个frame(无需遍历，通过保存在哈希表中的迭代器进行 $\mathcal{O}(1)$ 删除)，添加到 cache_list 中，同时维护哈希表 （3）new_count &gt; k，将这个 frame_id 移动到 cache_list 最后（删除和添加都可以做到 $\mathcal{O}(1)$ ）</li>
<li><strong>SetEvictable</strong> 和 <strong>Remove</strong>都可以类似的操作。</li>
</ul>
<h3 id="方法一时间复杂度">方法一时间复杂度：</h3>
<p>假设 history_list 和 cache_list 中的元素个数都是 n， 两个队列中 non-evictable 的个数都为 m，则 Evict 的时间复杂度为 $\mathcal{O}(m)$（最差遍历 m 个元素） 其余操作时间复杂度都是 $\mathcal{O}(1)$。需要注意的是，RecordAccess 要比 Evict 经常使用的多，且 Evict 遍历 m 个元素是在 non-evictable page 都在 evictable page 的先前访问。实际上可以看作一个常数。</p>
<h3 id="方法二">方法二</h3>
<p>为了绝对 $\mathcal{O}(1)$ 的 evict，我们可以使用std::set（红黑树），结点内部维护 <em>hit_count</em> 和 <em>到达时间</em>，需要重载&lt;=，就可以达到。但是这种做法不仅常数大（结点之间比较需要先比较访问了k次没有，对到达k次和没到达k次的结点还需分别比较），更致命的是它使得 <code>RecordAccess(frame_id)</code>的复杂度变成 $\mathcal{O}(log(n))$ （需要一次 find， 一次 delete，一次 insert）。</p>
<h2 id="summary">Summary</h2>
<p>这是四个实验（不算primer）中最简单的一个了，如果实在卡在某部分的话试试通过分析测试样例来得到预期行为，或者使用 gdb （可以使用 lldb 配合 vscode 代替命令行条件下进行调试）。相信我，越早学会如何调试对后面越有益。</p>
<p>最后当然是 AC 截图了</p>
<p><img loading="lazy" src="/img/busTub/buffer_pool_manager/p1-result.png" alt=""  />
</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li>
<li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li>
<li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
