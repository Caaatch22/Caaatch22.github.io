<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CMU15445-project3 Query Excution | Mingjie&#39;s Home</title>
<meta name="keywords" content="database, cmu15445">
<meta name="description" content="Overview

在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了浏览器上的bustub ，方便和我们写的对比调试。你也可以使用 explain 来查看他的优化策略与执行步骤。

这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B&#43;树）。


上图是 bustub 的整体架构。
Parser
sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个抽象语法树(AST, Abstract Syntax Tree)。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。
Binder
得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：
SELECT table1.y, table2.x FROM table1 INNER JOIN table2 ON table1.x = table2.y;
其中 SELECT 和 FROM 是关键字，x 和 table1 是标识符。我们可以使用 explain 来看看 binder 层（bustub-shell 未完成时也可以使用 explain）：
 === BINDER ===                                               
 BoundSelec {                                        
   table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=table1, oid=25 }, right=BoundBaseTableRef { table=table2, oid=26 }, condition=(table1.x=table2.y) }, 
   columns=[table1.y, table2.x],                       
   groupBy=[],
   having=,  
   where=,  
   limit=, 
   offset=,
   order_by=[],                                 
   is_distinct=false,         
   ctes=,
}
可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。">
<meta name="author" content="">
<link rel="canonical" href="https://caaatch22.github.io/posts/cmu15445-project3-query-execution/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.678b5c47efa744d2e0dd0d61101075e6aecdc9a0631e7ad8538f4ec0cca79273.css" integrity="sha256-Z4tcR&#43;&#43;nRNLg3Q1hEBB15q7NyaBjHnrYU49OwMynknM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://caaatch22.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://caaatch22.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://caaatch22.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://caaatch22.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://caaatch22.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://caaatch22.github.io/posts/cmu15445-project3-query-execution/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WEG841BBW9"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WEG841BBW9');
        }
      </script><meta property="og:title" content="CMU15445-project3 Query Excution" />
<meta property="og:description"
  content="Overview

在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了浏览器上的bustub ，方便和我们写的对比调试。你也可以使用 explain 来查看他的优化策略与执行步骤。

这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B&#43;树）。


上图是 bustub 的整体架构。
Parser
sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个抽象语法树(AST, Abstract Syntax Tree)。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。
Binder
得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：
SELECT table1.y, table2.x FROM table1 INNER JOIN table2 ON table1.x = table2.y;
其中 SELECT 和 FROM 是关键字，x 和 table1 是标识符。我们可以使用 explain 来看看 binder 层（bustub-shell 未完成时也可以使用 explain）：
 === BINDER ===                                               
 BoundSelec {                                        
   table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=table1, oid=25 }, right=BoundBaseTableRef { table=table2, oid=26 }, condition=(table1.x=table2.y) }, 
   columns=[table1.y, table2.x],                       
   groupBy=[],
   having=,  
   where=,  
   limit=, 
   offset=,
   order_by=[],                                 
   is_distinct=false,         
   ctes=,
}
可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://caaatch22.github.io/posts/cmu15445-project3-query-execution/" />
<meta property="og:image" content="https://caaatch22.github.io/img/busTub/query_excution/architecture-overview.png" /><meta property="article:section" content="posts" />

<meta property="article:published_time" content="2023-01-17T23:45:12+00:00" />

<meta property="article:modified_time" content="2023-01-17T23:45:12+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://caaatch22.github.io/img/busTub/query_excution/architecture-overview.png" />
<meta name="twitter:title" content="CMU15445-project3 Query Excution" />
<meta name="twitter:description"
    content="Overview

在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了浏览器上的bustub ，方便和我们写的对比调试。你也可以使用 explain 来查看他的优化策略与执行步骤。

这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B&#43;树）。


上图是 bustub 的整体架构。
Parser
sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个抽象语法树(AST, Abstract Syntax Tree)。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。
Binder
得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：
SELECT table1.y, table2.x FROM table1 INNER JOIN table2 ON table1.x = table2.y;
其中 SELECT 和 FROM 是关键字，x 和 table1 是标识符。我们可以使用 explain 来看看 binder 层（bustub-shell 未完成时也可以使用 explain）：
 === BINDER ===                                               
 BoundSelec {                                        
   table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=table1, oid=25 }, right=BoundBaseTableRef { table=table2, oid=26 }, condition=(table1.x=table2.y) }, 
   columns=[table1.y, table2.x],                       
   groupBy=[],
   having=,  
   where=,  
   limit=, 
   offset=,
   order_by=[],                                 
   is_distinct=false,         
   ctes=,
}
可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://caaatch22.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CMU15445-project3 Query Excution",
      "item": "https://caaatch22.github.io/posts/cmu15445-project3-query-execution/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CMU15445-project3 Query Excution",
  "name": "CMU15445-project3 Query Excution",
  "description": "Overview 在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了浏览器上的bustub ，方便和我们写的对比调试。你也可以使用 explain 来查看他的优化策略与执行步骤。\n这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。\n上图是 bustub 的整体架构。\nParser sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个抽象语法树(AST, Abstract Syntax Tree)。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。\nBinder 得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：\nSELECT table1.y, table2.x FROM table1 INNER JOIN table2 ON table1.x = table2.y; 其中 SELECT 和 FROM 是关键字，x 和 table1 是标识符。我们可以使用 explain 来看看 binder 层（bustub-shell 未完成时也可以使用 explain）：\n=== BINDER === BoundSelec { table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=table1, oid=25 }, right=BoundBaseTableRef { table=table2, oid=26 }, condition=(table1.x=table2.y) }, columns=[table1.y, table2.x], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } 可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。\n",
  "keywords": [
    "database", "cmu15445"
  ],
  "articleBody": "Overview 在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了浏览器上的bustub ，方便和我们写的对比调试。你也可以使用 explain 来查看他的优化策略与执行步骤。\n这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。\n上图是 bustub 的整体架构。\nParser sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个抽象语法树(AST, Abstract Syntax Tree)。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。\nBinder 得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：\nSELECT table1.y, table2.x FROM table1 INNER JOIN table2 ON table1.x = table2.y; 其中 SELECT 和 FROM 是关键字，x 和 table1 是标识符。我们可以使用 explain 来看看 binder 层（bustub-shell 未完成时也可以使用 explain）：\n=== BINDER === BoundSelec { table=BoundJoin { type=Inner, left=BoundBaseTableRef { table=table1, oid=25 }, right=BoundBaseTableRef { table=table2, oid=26 }, condition=(table1.x=table2.y) }, columns=[table1.y, table2.x], groupBy=[], having=, where=, limit=, offset=, order_by=[], is_distinct=false, ctes=, } 可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。\nPlanner 得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。查询计划也是一棵树的形式。例如这条 sql：\nSELECT table1.y, table2.x FROM table1 INNER JOIN table2 ON t1.x = t2.y; 查看 explain：\n=== PLANNER === Projection { exprs=[#0.1, #0.2] } | (table1.y:INTEGER, table2.x:INTEGER) NestedLoopJoin { type=Inner, predicate=(#0.0=#1.1) } | (table1.x:INTEGER, table1.y:INTEGER, table2.x:INTEGER, table2.y:INTEGER) SeqScan { table=table1 } | (table1.x:INTEGER, table1.y:INTEGER) SeqScan { table=table2 } | (table2.x:INTEGER, table2.y:INTEGER) 上面的解释其实是树型的，如下图： 查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。\nOptimizer 生成查询计划后 由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化，生成优化过后的最终查询计划。Optimizer 主要有两种实现方式：\nRule-based. 通过自动重写查询来避免效率低的方法。例如我们在 Task 3 中将要实现的，将 Limit + Sort 合并为 TopN。 这种 Optimizer 不需要知道数据的具体内容，仅是根据预先定义好的规则修改 Plan Node。 Cost-based. 用某种模型来预估执行计划的时间，这就需要存很多跟数据相关的数据 通过对不同模型的 cost 比较选出执行 cost 最小的。 这也会造成一些额外开销 （运行这个cost model） Bustub 的 Optimizer 采用第一种实现方式。\n一般来说，Planner 生成的是 Logical Plan Node，代表抽象的 Plan。Optimizer 则生成 Physical Plan Node，代表具体执行的 Plan。例如是 Join。在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。\nExecutor 在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了。算子也是我们在 Project 3 中需要实现的主要内容。生成算子的步骤很简单，遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor。算子的执行模型也大致分为三种：\nIterator/Pipeline Model(volcano model)。每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。火山模型一次调用只向下层算子请求一条数据，占用内存较小，但函数调用开销大。 Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高，但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。\nVectorized/Batch Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库采用这种模型。\nBustub 采用 Iterator Model。\nMetadata 上面介绍了 sql语句执行过程，足以让我们对整个执行引擎有大体了解。但是我在做这个 lab 时候还是有很多困惑的地方。最后是迷迷糊糊的写完了才整理了下。大体上的信息包括在下图中： （图片改自这篇博客）\nTask #1 - Access Method Executors SeqScan 实现比较简单，获取 table_iter 直接遍历即可。这里说说这个plan_-\u003efilter_predicate_， 他是一个AbstractExpressionRef，而一个AbstractExpression意思是一个 表达式 ，他里面最重要的两个函数是 Evaluate(const Tuple *tuple, const Schema \u0026schema)和 EvaluateJoin(const Tuple *left_tuple, const Schema \u0026left_schema, const Tuple *right_tuple, const Schema \u0026right_schema)，主要就是用来做 filter 的。例如\nselect * from table1 where x = 1; 如果任何优化都没有，那么上述语句可以解析为两层：\n从 table1 中选出所有的 tuple。 选出 x = 1的 tuple。相当于底下的 seqscan 结点会将所有 tuple 发到上一层，然后上一层再做一次 filter。但是我们通过谓词下推，可以在seqscan 时候就通过 filter_predicate_ 将需要的过滤出来，不需要的不用发给上一层。（当然，这个例子不太准确。在这个情况下本来就是一次搞定的，总之是在复杂的时候可以把谓词下推）。 这个 Evaluate 返回一个 Value，实际上如果做filter应该返回 boolean，所以需要通过filter_predicate_-\u003eEvaluate(tuple, table_info_-\u003eschema_).GetAs()转化一下。 另外，seqscan 实际上不会用到 filter_predicate。后面遇到需要 predicate 的地方会再强调。 Insert \u0026 Delete 这两个算子是唯二的写算子（实际上后面的优化过程中需要实现一个 update算子）。\n我们先看下这两个算子的行为：\nbustub\u003e insert into t1 values (0, '🥰', 10), (1, '🥰🥰', 11), (2, '🥰🥰🥰', 12), (3, '🥰🥰🥰🥰', 13), (4, '🥰🥰🥰🥰', 14); // output +-------------------------------+ | __bustub_internal.insert_rows | +-------------------------------+ | 5 | +-------------------------------+ 这两个算子他们会一直 next，然后返回一次，返回的是插入/删除 tuple 的个数（所生成的tuple）。有点像 pipeline breaker，但是由于他们一定是顶层算子，所以好像不叫 pipeline breaker。\n个人感觉这个返回个数的设计有点不是很合理，它一定要将个数转化成一个tuple返回。大概是这样的操作。\n*tuple = Tuple(std::vector\u003cValue\u003e(GetOutputSchema().GetColumnCount() /* ColumnCount() should be one*/, Value(TypeId::INTEGER, counter)), \u0026GetOutputSchema()); 另外需要注意的就是这些 增加/删除 tuple 时，对应的索引项也需要增加/删除。\nIndexScan 这个就简单了，在 Init() 时候保存 index_iter， next() 时直接调用再自增就可以。\nTask #2 - Aggregation \u0026 Join Executors Aggregation aggregation 操作是一个 pipeline breaker。他会在 init 得到全部答案然后再 next 时一条一条返回。\nSimpleAggregationHashTable 维护一张哈希表，键为 AggregateKey，值为 AggregateValue，均为 std::vector。key 代表 group by 的字段的数组，value 则是需要 aggregate 的字段的数组。在下层算子传来一个 tuple 时，将 tuple 的 group by 字段和 aggregate 字段分别提取出来，调用 InsertCombine() 将 group by 和 aggregate 的映射关系存入 SimpleAggregationHashTable。若当前 hashmap 中没有 group by 的记录，则创建初值；若已有记录，则按 aggregate 规则逐一更新所有的 aggregate 字段，例如取 max/min，求 sum 等等。例如下面这条 sql：\nSELECT min(t.z), max(t.z), sum(t.z) FROM t GROUP BY t.x, t.y; group by（AggregateKey）为 {t.x, t.y}，aggregate（AggregateValue）为 {t.z, t.z, t.z}。aggregate 规则为 {min, max, sum}。\n需要额外注意 count(column) 和 count(*) 的区别，以及对空值的处理。\n在 Init() 中计算出整张 hashmap 后，在 Next() 中直接利用 hashmap iterator 将结果依次取出。这里的输出形式有点奇怪，需要这样的输出： schema 已经在 GetOutputSchema() 中准备好了。\nNestedLoopJoin 我的实现比较 tricky。我在 init 时候直接把下层算子（left_executor和right_executor）所有的tuple都得到了（相当于当作 pipeline breaker），保存在两张表中。再 next时候进行匹配。这里的 left-join 和 inner-join 是需要分开实现的，可以在网上查下left-join和inner-join的区别。 在这里判断左右两个 tuple 是否 match 就需要用到plan_-\u003ePredicate().EvaluateJoin()，同样要 GetAs()。\n当我们得到一个 match 后，返回前记得保存上下文，例如，你可以保存 match 的 tuple 再左表中的下标和右表中的下标，这样下次调用 next 时候，就不用重新扫描一次。\nNestedIndexJoin 在进行 equi-join 时，如果发现 JOIN ON 右边的字段上建了 index，则 Optimizer 会将 NestedLoopJoin 优化为 NestedIndexJoin。具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。\nTask #3 - Sort + Limit Executors and Top-N Optimization sort 这个实验的 sort 无需进行外部排序，重载小于后就可以实现。就是比较的方式有点奇怪，可以类比以下写：\norder_key.second-\u003eEvaluate(\u0026lhs, schema).CompareLessThan(order_key.second-\u003eEvaluate(\u0026rhs, schema)) limit 简单，limit 限制在 plan_-\u003eGetlimit()里面。\nTop-N Optimization Rule 简单，优先队列重载小于（重载方式与 sort 相同），然后截取前 n 个。\nSort + Limit As TopN 这是 Project 3 里最后一个必做的小问，也是唯一一个 Optimizer ，将 Sort + Limit 优化为 TopN。先看看 Optimizer 是如何执行优化规则的：\nauto Optimizer::OptimizeCustom(const AbstractPlanNodeRef \u0026plan) -\u003e AbstractPlanNodeRef { auto p = plan; p = OptimizeMergeProjection(p); p = OptimizeMergeFilterNLJ(p); p = OptimizeNLJAsIndexJoin(p); p = OptimizeNLJAsHashJoin(p); // Enable this rule after you have implemented hash join. p = OptimizeOrderByAsIndexScan(p); p = OptimizeSortLimitAsTopN(p); // what we should add return p; } 可以看到，让未经优化的原始 plan 树依次经历多条规则，来生成优化过的 plan。我们的任务就是新增一条规则。看看其他规则是怎么实现的，例如 NLJAsIndexJoin：\nauto Optimizer::OptimizeNLJAsIndexJoin(const AbstractPlanNodeRef \u0026plan) -\u003e AbstractPlanNodeRef { std::vector\u003cAbstractPlanNodeRef\u003e children; for (const auto \u0026child : plan-\u003eGetChildren()) { children.emplace_back(OptimizeNLJAsIndexJoin(child)); } auto optimized_plan = plan-\u003eCloneWithChildren(std::move(children)); if (optimized_plan-\u003eGetType() == PlanType::NestedLoopJoin) { // apply the rule and return } return optimized_plan; } 可以看到，实际上就是对 plan tree 进行后序遍历，自底向上地适用规则，改写节点。遍历到某个节点时，通过 if 语句来判断当前节点的类型是否符合我们要优化的类型，若符合则进行优化。\n大致了解如何对 plan 进行优化后，就可以开始写我们的优化规则了。需要特别注意的是，能优化为一个 TopN 算子的形式是，上层节点为 Limit，下层节点为 Sort，不能反过来。同样，我们对 plan tree 进行后续遍历，在遇到 Limit 时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN。还是比较好实现的，只是代码看起来可能有点复杂。\nLeaderboard Task 暂时还没写，有空了补补\nAC! Resources bustub on web 课程官网 Github Repo Youtube课程视频 2022fall （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件） ",
  "wordCount" : "736",
  "inLanguage": "en",
  "image":"https://caaatch22.github.io/img/busTub/query_excution/architecture-overview.png","datePublished": "2023-01-17T23:45:12Z",
  "dateModified": "2023-01-17T23:45:12Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://caaatch22.github.io/posts/cmu15445-project3-query-execution/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mingjie's Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://caaatch22.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://caaatch22.github.io/" accesskey="h" title="Mingjie&#39;s Home (Alt + H)">Mingjie&#39;s Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://caaatch22.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://caaatch22.github.io/cv/" title="CV">
                    <span>CV</span>
                </a>
            </li>
            <li>
                <a href="https://caaatch22.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://caaatch22.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://caaatch22.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://caaatch22.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      CMU15445-project3 Query Excution
    </h1>
    <div class="post-meta">&lt;span title=&#39;2023-01-17 23:45:12 &#43;0000 UTC&#39;&gt;January 17, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;4 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#overview" aria-label="Overview">Overview</a><ul>
                            
                    <li>
                        <a href="#parser" aria-label="Parser">Parser</a></li>
                    <li>
                        <a href="#binder" aria-label="Binder">Binder</a></li>
                    <li>
                        <a href="#planner" aria-label="Planner">Planner</a></li>
                    <li>
                        <a href="#optimizer" aria-label="Optimizer">Optimizer</a></li>
                    <li>
                        <a href="#executor" aria-label="Executor">Executor</a></li></ul>
                    </li>
                    <li>
                        <a href="#metadata" aria-label="Metadata">Metadata</a></li>
                    <li>
                        <a href="#task-1---access-method-executors" aria-label="Task #1 - Access Method Executors">Task #1 - Access Method Executors</a><ul>
                            
                    <li>
                        <a href="#seqscan" aria-label="SeqScan">SeqScan</a></li>
                    <li>
                        <a href="#insert--delete" aria-label="Insert &amp; Delete">Insert &amp; Delete</a></li>
                    <li>
                        <a href="#indexscan" aria-label="IndexScan">IndexScan</a></li></ul>
                    </li>
                    <li>
                        <a href="#task-2---aggregation--join-executors" aria-label="Task #2 - Aggregation &amp; Join Executors">Task #2 - Aggregation &amp; Join Executors</a><ul>
                            
                    <li>
                        <a href="#aggregation" aria-label="Aggregation">Aggregation</a></li>
                    <li>
                        <a href="#nestedloopjoin" aria-label="NestedLoopJoin">NestedLoopJoin</a></li>
                    <li>
                        <a href="#nestedindexjoin" aria-label="NestedIndexJoin">NestedIndexJoin</a></li></ul>
                    </li>
                    <li>
                        <a href="#task-3---sort--limit-executors-and-top-n-optimization" aria-label="Task #3 - Sort &#43; Limit Executors and Top-N Optimization">Task #3 - Sort + Limit Executors and Top-N Optimization</a><ul>
                            
                    <li>
                        <a href="#sort" aria-label="sort">sort</a></li>
                    <li>
                        <a href="#limit" aria-label="limit">limit</a></li>
                    <li>
                        <a href="#top-n-optimization-rule" aria-label="Top-N Optimization Rule">Top-N Optimization Rule</a></li>
                    <li>
                        <a href="#sort--limit-as-topn" aria-label="Sort &#43; Limit As TopN">Sort + Limit As TopN</a></li></ul>
                    </li>
                    <li>
                        <a href="#leaderboard-task" aria-label="Leaderboard Task">Leaderboard Task</a></li>
                    <li>
                        <a href="#resources" aria-label="Resources">Resources</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<blockquote>
<p>在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了<a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">浏览器上的bustub</a> ，方便和我们写的对比调试。你也可以使用 <code>explain</code> 来查看他的优化策略与执行步骤。</p>
</blockquote>
<p>这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。</p>
<p><img loading="lazy" src="/img/busTub/query_excution/project-structure.png" alt=""  />
</p>
<p>上图是 bustub 的整体架构。</p>
<h3 id="parser">Parser<a hidden class="anchor" aria-hidden="true" href="#parser">#</a></h3>
<p>sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个<em>抽象语法树(AST, Abstract Syntax Tree)</em>。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。</p>
<h3 id="binder">Binder<a hidden class="anchor" aria-hidden="true" href="#binder">#</a></h3>
<p>得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> table1.y, table2.x <span style="color:#66d9ef">FROM</span> table1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> table2 <span style="color:#66d9ef">ON</span> table1.x <span style="color:#f92672">=</span> table2.y;
</span></span></code></pre></div><p>其中 <code>SELECT</code> 和 <code>FROM</code> 是关键字，<code>x</code> 和 <code>table1</code> 是标识符。我们可以使用 <code>explain</code> 来看看 <code>binder</code> 层（bustub-shell 未完成时也可以使用 explain）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#f92672">===</span> BINDER <span style="color:#f92672">===</span>                                               
</span></span><span style="display:flex;"><span> BoundSelec <span style="color:#f92672">{</span>                                        
</span></span><span style="display:flex;"><span>   table<span style="color:#f92672">=</span>BoundJoin <span style="color:#f92672">{</span> type<span style="color:#f92672">=</span>Inner, left<span style="color:#f92672">=</span>BoundBaseTableRef <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table1, oid<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span> <span style="color:#f92672">}</span>, right<span style="color:#f92672">=</span>BoundBaseTableRef <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table2, oid<span style="color:#f92672">=</span><span style="color:#ae81ff">26</span> <span style="color:#f92672">}</span>, condition<span style="color:#f92672">=(</span>table1.x<span style="color:#f92672">=</span>table2.y<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>, 
</span></span><span style="display:flex;"><span>   columns<span style="color:#f92672">=[</span>table1.y, table2.x<span style="color:#f92672">]</span>,                       
</span></span><span style="display:flex;"><span>   groupBy<span style="color:#f92672">=[]</span>,
</span></span><span style="display:flex;"><span>   having<span style="color:#f92672">=</span>,  
</span></span><span style="display:flex;"><span>   where<span style="color:#f92672">=</span>,  
</span></span><span style="display:flex;"><span>   limit<span style="color:#f92672">=</span>, 
</span></span><span style="display:flex;"><span>   offset<span style="color:#f92672">=</span>,
</span></span><span style="display:flex;"><span>   order_by<span style="color:#f92672">=[]</span>,                                 
</span></span><span style="display:flex;"><span>   is_distinct<span style="color:#f92672">=</span>false,         
</span></span><span style="display:flex;"><span>   ctes<span style="color:#f92672">=</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。</p>
<h3 id="planner">Planner<a hidden class="anchor" aria-hidden="true" href="#planner">#</a></h3>
<p>得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。查询计划也是一棵树的形式。例如这条 sql：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> table1.y, table2.x <span style="color:#66d9ef">FROM</span> table1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> table2 <span style="color:#66d9ef">ON</span> t1.x <span style="color:#f92672">=</span> t2.y;
</span></span></code></pre></div><p>查看 explain：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#f92672">===</span> PLANNER <span style="color:#f92672">===</span>
</span></span><span style="display:flex;"><span> Projection <span style="color:#f92672">{</span> exprs<span style="color:#f92672">=[</span><span style="color:#75715e">#0.1, #0.2] } | (table1.y:INTEGER, table2.x:INTEGER)                                                                                            </span>
</span></span><span style="display:flex;"><span>   NestedLoopJoin <span style="color:#f92672">{</span> type<span style="color:#f92672">=</span>Inner, predicate<span style="color:#f92672">=(</span><span style="color:#75715e">#0.0=#1.1) } | (table1.x:INTEGER, table1.y:INTEGER, table2.x:INTEGER, table2.y:INTEGER)                                   </span>
</span></span><span style="display:flex;"><span>     SeqScan <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table1 <span style="color:#f92672">}</span> | <span style="color:#f92672">(</span>table1.x:INTEGER, table1.y:INTEGER<span style="color:#f92672">)</span>                                                                                                 
</span></span><span style="display:flex;"><span>     SeqScan <span style="color:#f92672">{</span> table<span style="color:#f92672">=</span>table2 <span style="color:#f92672">}</span> | <span style="color:#f92672">(</span>table2.x:INTEGER, table2.y:INTEGER<span style="color:#f92672">)</span> 
</span></span></code></pre></div><p>上面的解释其实是树型的，如下图：
<img loading="lazy" src="/img/busTub/query_excution/planner-tree.png" alt=""  />

查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。</p>
<h3 id="optimizer">Optimizer<a hidden class="anchor" aria-hidden="true" href="#optimizer">#</a></h3>
<p>生成查询计划后
由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化，生成优化过后的最终查询计划。Optimizer 主要有两种实现方式：</p>
<ul>
<li>Rule-based.
<ul>
<li>通过自动重写查询来避免效率低的方法。例如我们在 Task 3 中将要实现的，将 <code>Limit + Sort</code> 合并为 <code>TopN</code>。</li>
<li>这种 Optimizer 不需要知道数据的具体内容，仅是根据预先定义好的规则修改 <code>Plan Node</code>。</li>
</ul>
</li>
<li>Cost-based.
<ul>
<li>用某种模型来预估执行计划的时间，这就需要存很多跟数据相关的数据</li>
<li>通过对不同模型的 cost 比较选出执行 cost 最小的。</li>
<li>这也会造成一些额外开销 （运行这个cost model）</li>
</ul>
</li>
</ul>
<p>Bustub 的 Optimizer 采用第一种实现方式。</p>
<blockquote>
<p>一般来说，Planner 生成的是 Logical Plan Node，代表抽象的 Plan。Optimizer 则生成 Physical Plan Node，代表具体执行的 Plan。例如是 Join。在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。</p>
</blockquote>
<h3 id="executor">Executor<a hidden class="anchor" aria-hidden="true" href="#executor">#</a></h3>
<p>在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了。算子也是我们在 Project 3 中需要实现的主要内容。生成算子的步骤很简单，遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor。算子的执行模型也大致分为三种：</p>
<ol>
<li>
<p>Iterator/Pipeline Model(volcano model)。每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。火山模型一次调用只向下层算子请求一条数据，占用内存较小，但函数调用开销大。 <img loading="lazy" src="/img/busTub/query_excution/iterator-model.png" alt=""  />
</p>
</li>
<li>
<p>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高，但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</p>
</li>
<li>
<p>Vectorized/Batch Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库采用这种模型。</p>
</li>
</ol>
<p>Bustub 采用 Iterator Model。</p>
<h2 id="metadata">Metadata<a hidden class="anchor" aria-hidden="true" href="#metadata">#</a></h2>
<p>上面介绍了 sql语句执行过程，足以让我们对整个执行引擎有大体了解。但是我在做这个 lab 时候还是有很多困惑的地方。最后是迷迷糊糊的写完了才整理了下。大体上的信息包括在下图中：
<img loading="lazy" src="/img/busTub/query_excution/table-matedata.png" alt=""  />

（图片改自<a href="https://blog.eleven.wiki/posts/cmu15-445-project3-query-execution/">这篇博客</a>）</p>
<h2 id="task-1---access-method-executors">Task #1 - Access Method Executors<a hidden class="anchor" aria-hidden="true" href="#task-1---access-method-executors">#</a></h2>
<h3 id="seqscan">SeqScan<a hidden class="anchor" aria-hidden="true" href="#seqscan">#</a></h3>
<p>实现比较简单，获取 table_iter 直接遍历即可。这里说说这个<code>plan_-&gt;filter_predicate_</code>， 他是一个<code>AbstractExpressionRef</code>，而一个<code>AbstractExpression</code>意思是一个 <em>表达式</em> ，他里面最重要的两个函数是 <code>Evaluate(const Tuple *tuple, const Schema &amp;schema)</code>和 <code>EvaluateJoin(const Tuple *left_tuple, const Schema &amp;left_schema, const Tuple *right_tuple, const Schema &amp;right_schema)</code>，主要就是用来做 filter 的。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> table1 <span style="color:#66d9ef">where</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>如果任何优化都没有，那么上述语句可以解析为两层：</p>
<ol>
<li>从 table1 中选出所有的 tuple。</li>
<li>选出 x = 1的 tuple。相当于底下的 seqscan 结点会将所有 tuple 发到上一层，然后上一层再做一次 filter。但是我们通过谓词下推，可以在seqscan 时候就通过 filter_predicate_ 将需要的过滤出来，不需要的不用发给上一层。（当然，这个例子不太准确。在这个情况下本来就是一次搞定的，总之是在复杂的时候可以把谓词下推）。
这个 Evaluate 返回一个 <code>Value</code>，实际上如果做filter应该返回 boolean，所以需要通过<code>filter_predicate_-&gt;Evaluate(tuple, table_info_-&gt;schema_).GetAs&lt;bool&gt;()</code>转化一下。
另外，seqscan 实际上不会用到 filter_predicate。后面遇到需要 predicate 的地方会再强调。</li>
</ol>
<h3 id="insert--delete">Insert &amp; Delete<a hidden class="anchor" aria-hidden="true" href="#insert--delete">#</a></h3>
<p>这两个算子是唯二的写算子（实际上后面的优化过程中需要实现一个 update算子）。</p>
<p>我们先看下这两个算子的行为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>bustub<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span> (<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;🥰&#39;</span>, <span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;🥰🥰&#39;</span>, <span style="color:#ae81ff">11</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;🥰🥰🥰&#39;</span>, <span style="color:#ae81ff">12</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;🥰🥰🥰🥰&#39;</span>, <span style="color:#ae81ff">13</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;🥰🥰🥰🥰&#39;</span>, <span style="color:#ae81ff">14</span>);
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span> <span style="color:#66d9ef">output</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#75715e">-------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">|</span> __bustub_internal.insert_rows <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#75715e">-------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">|</span> <span style="color:#ae81ff">5</span>                             <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#75715e">-------------------------------+
</span></span></span></code></pre></div><p>这两个算子他们会一直 next，然后返回一次，返回的是插入/删除 tuple 的个数（所生成的tuple）。有点像 <code>pipeline breaker</code>，但是由于他们一定是顶层算子，所以好像不叫 <code>pipeline breaker</code>。</p>
<p>个人感觉这个返回个数的设计有点不是很合理，它一定要将个数转化成一个tuple返回。大概是这样的操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#f92672">*</span>tuple <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      Tuple(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span>(GetOutputSchema().GetColumnCount() <span style="color:#75715e">/* ColumnCount() should be one*/</span>, Value(TypeId<span style="color:#f92672">::</span>INTEGER, counter)),
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>GetOutputSchema());
</span></span></code></pre></div><p>另外需要注意的就是这些 增加/删除 tuple 时，对应的索引项也需要增加/删除。</p>
<h3 id="indexscan">IndexScan<a hidden class="anchor" aria-hidden="true" href="#indexscan">#</a></h3>
<p>这个就简单了，在 Init() 时候保存 index_iter， next() 时直接调用再自增就可以。</p>
<h2 id="task-2---aggregation--join-executors">Task #2 - Aggregation &amp; Join Executors<a hidden class="anchor" aria-hidden="true" href="#task-2---aggregation--join-executors">#</a></h2>
<h3 id="aggregation">Aggregation<a hidden class="anchor" aria-hidden="true" href="#aggregation">#</a></h3>
<p>aggregation 操作是一个 <code>pipeline breaker</code>。他会在 init 得到全部答案然后再 next 时一条一条返回。</p>
<p><code>SimpleAggregationHashTable</code> 维护一张哈希表，键为 <code>AggregateKey</code>，值为 <code>AggregateValue</code>，均为 <code>std::vector&lt;Value&gt;</code>。key 代表 group by 的字段的数组，value 则是需要 aggregate 的字段的数组。在下层算子传来一个 tuple 时，将 tuple 的 group by 字段和 aggregate 字段分别提取出来，调用 <code>InsertCombine()</code> 将 group by 和 aggregate 的映射关系存入 <code>SimpleAggregationHashTable</code>。若当前 hashmap 中没有 group by 的记录，则创建初值；若已有记录，则按 aggregate 规则逐一更新所有的 aggregate 字段，例如取 max/min，求 sum 等等。例如下面这条 sql：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">min</span>(t.z), <span style="color:#66d9ef">max</span>(t.z), <span style="color:#66d9ef">sum</span>(t.z) <span style="color:#66d9ef">FROM</span> t <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> t.x, t.y;
</span></span></code></pre></div><p>group by（AggregateKey）为 {t.x, t.y}，aggregate（AggregateValue）为 {t.z, t.z, t.z}。aggregate 规则为 {min, max, sum}。</p>
<p>需要额外注意 <code>count(column)</code> 和 <code>count(*)</code> 的区别，以及对空值的处理。</p>
<p>在 Init() 中计算出整张 hashmap 后，在 Next() 中直接利用 hashmap iterator 将结果依次取出。这里的输出形式有点奇怪，需要这样的输出：
<img loading="lazy" src="/img/busTub/query_excution/aggregate-return.png" alt=""  />
</p>
<p><code>schema</code> 已经在 <code>GetOutputSchema()</code> 中准备好了。</p>
<h3 id="nestedloopjoin">NestedLoopJoin<a hidden class="anchor" aria-hidden="true" href="#nestedloopjoin">#</a></h3>
<p>我的实现比较 tricky。我在 init 时候直接把下层算子（left_executor和right_executor）所有的tuple都得到了（相当于当作 pipeline breaker），保存在两张表中。再 next时候进行匹配。这里的 left-join 和 inner-join 是需要分开实现的，可以在网上查下left-join和inner-join的区别。
在这里判断左右两个 tuple 是否 match 就需要用到<code>plan_-&gt;Predicate().EvaluateJoin()</code>，同样要 <code>GetAs&lt;bool&gt;()</code>。</p>
<p>当我们得到一个 match 后，返回前记得<strong>保存上下文</strong>，例如，你可以保存 match 的 tuple 再左表中的下标和右表中的下标，这样下次调用 next 时候，就不用重新扫描一次。</p>
<h3 id="nestedindexjoin">NestedIndexJoin<a hidden class="anchor" aria-hidden="true" href="#nestedindexjoin">#</a></h3>
<p>在进行 equi-join 时，如果发现 JOIN ON 右边的字段上建了 index，则 Optimizer 会将 NestedLoopJoin 优化为 NestedIndexJoin。具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p>
<h2 id="task-3---sort--limit-executors-and-top-n-optimization">Task #3 - Sort + Limit Executors and Top-N Optimization<a hidden class="anchor" aria-hidden="true" href="#task-3---sort--limit-executors-and-top-n-optimization">#</a></h2>
<h3 id="sort">sort<a hidden class="anchor" aria-hidden="true" href="#sort">#</a></h3>
<p>这个实验的 sort 无需进行外部排序，重载小于后就可以实现。就是比较的方式有点奇怪，可以类比以下写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>order_key.second<span style="color:#f92672">-&gt;</span>Evaluate(<span style="color:#f92672">&amp;</span>lhs, schema).CompareLessThan(order_key.second<span style="color:#f92672">-&gt;</span>Evaluate(<span style="color:#f92672">&amp;</span>rhs, schema))
</span></span></code></pre></div><h3 id="limit">limit<a hidden class="anchor" aria-hidden="true" href="#limit">#</a></h3>
<p>简单，limit 限制在 <code>plan_-&gt;Getlimit()</code>里面。</p>
<h3 id="top-n-optimization-rule">Top-N Optimization Rule<a hidden class="anchor" aria-hidden="true" href="#top-n-optimization-rule">#</a></h3>
<p>简单，优先队列重载小于（重载方式与 sort 相同），然后截取前 n 个。</p>
<h3 id="sort--limit-as-topn">Sort + Limit As TopN<a hidden class="anchor" aria-hidden="true" href="#sort--limit-as-topn">#</a></h3>
<p>这是 Project 3 里最后一个必做的小问，也是唯一一个 Optimizer ，将 Sort + Limit 优化为 TopN。先看看 Optimizer 是如何执行优化规则的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> Optimizer<span style="color:#f92672">::</span>OptimizeCustom(<span style="color:#66d9ef">const</span> AbstractPlanNodeRef <span style="color:#f92672">&amp;</span>plan) <span style="color:#f92672">-&gt;</span> AbstractPlanNodeRef {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> plan;
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeMergeProjection(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeMergeFilterNLJ(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeNLJAsIndexJoin(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeNLJAsHashJoin(p);  <span style="color:#75715e">// Enable this rule after you have implemented hash join.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  p <span style="color:#f92672">=</span> OptimizeOrderByAsIndexScan(p);
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> OptimizeSortLimitAsTopN(p);  <span style="color:#75715e">// what we should add
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到，让未经优化的原始 plan 树依次经历多条规则，来生成优化过的 plan。我们的任务就是新增一条规则。看看其他规则是怎么实现的，例如 NLJAsIndexJoin：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> Optimizer<span style="color:#f92672">::</span>OptimizeNLJAsIndexJoin(<span style="color:#66d9ef">const</span> AbstractPlanNodeRef <span style="color:#f92672">&amp;</span>plan) <span style="color:#f92672">-&gt;</span> AbstractPlanNodeRef {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AbstractPlanNodeRef<span style="color:#f92672">&gt;</span> children;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>child : plan<span style="color:#f92672">-&gt;</span>GetChildren()) {
</span></span><span style="display:flex;"><span>    children.emplace_back(OptimizeNLJAsIndexJoin(child));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> optimized_plan <span style="color:#f92672">=</span> plan<span style="color:#f92672">-&gt;</span>CloneWithChildren(std<span style="color:#f92672">::</span>move(children));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (optimized_plan<span style="color:#f92672">-&gt;</span>GetType() <span style="color:#f92672">==</span> PlanType<span style="color:#f92672">::</span>NestedLoopJoin) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// apply the rule and return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> optimized_plan;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到，实际上就是对 plan tree 进行后序遍历，自底向上地适用规则，改写节点。遍历到某个节点时，通过 if 语句来判断当前节点的类型是否符合我们要优化的类型，若符合则进行优化。</p>
<p>大致了解如何对 plan 进行优化后，就可以开始写我们的优化规则了。需要特别注意的是，能优化为一个 TopN 算子的形式是，上层节点为 Limit，下层节点为 Sort，不能反过来。同样，我们对 plan tree 进行后续遍历，在遇到 Limit 时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN。还是比较好实现的，只是代码看起来可能有点复杂。</p>
<h2 id="leaderboard-task">Leaderboard Task<a hidden class="anchor" aria-hidden="true" href="#leaderboard-task">#</a></h2>
<p>暂时还没写，有空了补补</p>
<p><strong>AC!</strong>
<img loading="lazy" src="/img/busTub/query_excution/p3-result.png" alt=""  />
</p>
<h2 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h2>
<ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">bustub on web</a></li>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li>
<li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li>
<li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://caaatch22.github.io/tags/database/">Database</a></li>
      <li><a href="https://caaatch22.github.io/tags/cmu15445/">Cmu15445</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://caaatch22.github.io/posts/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93-httpserver/">
    <span class="title">« Prev</span>
    <br>
    <span>轻量级高并发网络库&#43;httpserver</span>
  </a>
  <a class="next" href="https://caaatch22.github.io/posts/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84wavelet-tree/">
    <span class="title">Next »</span>
    <br>
    <span>将Wavelet Tree用于算法竞赛</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://caaatch22.github.io/">Mingjie&#39;s Home</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
