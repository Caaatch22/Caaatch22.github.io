<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DataStructure on Mingjie&#39;s Home</title>
    <link>https://caaatch22.github.io/tags/datastructure/</link>
    <description>Recent content in DataStructure on Mingjie&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 23 Jul 2023 21:23:15 +0000</lastBuildDate><atom:link href="https://caaatch22.github.io/tags/datastructure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>phmap —— 缓存友好的高效hashtable</title>
      <link>https://caaatch22.github.io/posts/phmap/</link>
      <pubDate>Sun, 23 Jul 2023 21:23:15 +0000</pubDate>
      
      <guid>https://caaatch22.github.io/posts/phmap/</guid>
      <description>众所周知，C++标准库的 unordered_map在性能上向来不是一个好的选择。开源市场上有非常多的高性能哈希表可供选择，phmap继承自 absl-hashmap，有着非常好的插入、查找性能。在著名的Comprehensive C++ Hashmap Benchmarks 2022榜单中名列前茅。事实上，我比对了 phmap::flat_hash_map与榜单中综合性能第一的 ankerl::unordered_dense::map，我的benchmark中只有遍历哈希表时，flat_hash_map的性能低于 unordered_dense::map，其余无论是插入还是随即查找，大部分情况下 flat_hash_map的性能都更优。本文简单介绍了 flat_hash_map相关情况，以及一些使用上的建议与坑点。
flat_hash_map 和 node_hash_map区别 phmap中有提供了两类哈希表，其内部布局示意图如下：
由上图（忽略了bucket的细节）可以看出，flat_hash_map的最大的优点在于
node之间的内存是连续的(虽然可能中间存在空node)，遍历的时候对cache更加友好 并且相比于 node_hash_map版少一次寻址过程（std::unordered_map的设计与 node_hash_map）相同。 而 flat_*系列的缺点就是在 rehash的时候:
会引发原来的value失效（这里的失效指的是原来的那个对象所对应的内存失效，而不是value所包含的内容失效，例如，value是一个指针，那它的值——所指向的对象，不会受到影响）。举个例子： flat_hash_map&amp;lt;int, Data&amp;gt; mp; node_hash_map&amp;lt;int, Data&amp;gt; nodemp; mp[0] = Data(); nodemp[0] = Data(); auto&amp;amp; mp0 = mp[0]; auto&amp;amp; nodemp0 = nodemp[0]; // tigger rehash for (int i = 1; i &amp;lt;= 10; i ++) { mp[i] = Data(); nodemp[i] = Data(); } assert(std::addressof(mp[0]) != std::addressof(mp0)); assert(std::addressof(nodemp[0]) == std::addressof(nodemp0)); 原因就是 flat_hash_map的内存布局导致的。而 node_hash_map或者 std::unordered_map就保证不会出现这种情况，因为当他们rehash的时候，只需要将bucket内的指针重新分配，指针的值还是指向原来的 node&amp;lt;key, value&amp;gt;.</description>
      <content:encoded><![CDATA[<blockquote>
<p>众所周知，C++标准库的 <code>unordered_map</code>在性能上向来不是一个好的选择。开源市场上有非常多的高性能哈希表可供选择，<a href="https://github.com/greg7mdp/parallel-hashmap">phmap</a>继承自 <code>absl-hashmap</code>，有着非常好的插入、查找性能。在著名的<a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/#benchmark-results-table">Comprehensive C++ Hashmap Benchmarks 2022</a>榜单中名列前茅。事实上，我比对了 <code>phmap::flat_hash_map</code>与榜单中综合性能第一的 <code>ankerl::unordered_dense::map</code>，我的benchmark中只有遍历哈希表时，<code>flat_hash_map</code>的性能低于 <code>unordered_dense::map</code>，其余无论是插入还是随即查找，大部分情况下 <code>flat_hash_map</code>的性能都更优。本文简单介绍了 <code>flat_hash_map</code>相关情况，以及一些使用上的建议与坑点。</p>
</blockquote>
<h3 id="flat_hash_map-和-node_hash_map区别">flat_hash_map 和 node_hash_map区别</h3>
<p>phmap中有提供了两类哈希表，其内部布局示意图如下：</p>
<p><img loading="lazy" src="/img/phmap/flat_hash_map-vs-node_hash_map.png" alt=""  />
</p>
<p>由上图（忽略了bucket的细节）可以看出，<code>flat_hash_map</code>的最大的优点在于</p>
<ol>
<li>node之间的内存是连续的(虽然可能中间存在空node)，遍历的时候对cache更加友好</li>
<li>并且相比于 <code>node_hash_map</code>版少一次寻址过程（<code>std::unordered_map</code>的设计与 <code>node_hash_map</code>）相同。</li>
</ol>
<p>而 <code>flat_*</code>系列的缺点就是在 <code>rehash</code>的时候:</p>
<ol>
<li>会引发原来的value<strong>失效</strong>（这里的失效指的是原来的那个对象所对应的内存失效，而不是value所包含的内容失效，例如，value是一个指针，那它的值——所指向的对象，不会受到影响）。举个例子：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flat_hash_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, Data<span style="color:#f92672">&gt;</span> mp;
</span></span><span style="display:flex;"><span>node_hash_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, Data<span style="color:#f92672">&gt;</span> nodemp;
</span></span><span style="display:flex;"><span>mp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Data();
</span></span><span style="display:flex;"><span>nodemp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Data();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> mp0 <span style="color:#f92672">=</span> mp[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> nodemp0 <span style="color:#f92672">=</span> nodemp[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// tigger rehash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span>; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>	mp[i] <span style="color:#f92672">=</span> Data();
</span></span><span style="display:flex;"><span>	nodemp[i] <span style="color:#f92672">=</span> Data(); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>assert(std<span style="color:#f92672">::</span>addressof(mp[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">!=</span> std<span style="color:#f92672">::</span>addressof(mp0));
</span></span><span style="display:flex;"><span>assert(std<span style="color:#f92672">::</span>addressof(nodemp[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> std<span style="color:#f92672">::</span>addressof(nodemp0));
</span></span></code></pre></div><p>原因就是 <code>flat_hash_map</code>的内存布局导致的。而 <code>node_hash_map</code>或者 <code>std::unordered_map</code>就保证不会出现这种情况，因为当他们rehash的时候，只需要将bucket内的指针重新分配，指针的值还是指向原来的 <code>node&lt;key, value&gt;</code>.</p>
<ol start="2">
<li>由上述原因引发的性能问题： 当 <code>node&lt;pair, value&gt;</code>很大的时候，<code>flat_hash_map</code>每次 rehash 需要重新构造的开销大，而 <code>node_hash_map</code>只需要重新构造相同数量的指针。并且遍历时也因为两个node之间相隔较大使得 cache locality 下降。</li>
</ol>
<h3 id="使用建议单线程">使用建议(单线程)</h3>
<p>绝大多数情况下直接用 <code>flat_hash_map</code>:</p>
<ol>
<li><code>int -&gt; int</code></li>
<li><code>int -&gt; string</code></li>
<li><code>string-&gt;int</code></li>
<li><code>string(sso) -&gt; string(sso)</code></li>
<li><code>string(none-sso)-&gt;string(none-sso)</code></li>
</ol>
<p>少数情况用 <code>node_hash_map</code>:</p>
<ol>
<li><code>key -&gt; Large Data</code></li>
</ol>
<p>这种情况强烈建议用 <code>flat_hash_map&lt;key, ptr&lt;Large Data&gt;&gt;</code>代替</p>
<p>有意思的一点是为什么经过实测 <code>string(none-sso) -&gt; string(none-sso)</code>这种情况下仍然是 <code>flat_hash_map</code>更快一点，难道string(none-sso)不是Large Data吗？</p>
<p>事实上，<code>string</code> 虽然可能很大，但是其 <code>raw data</code>存在另外分配的一个空间（超过短字符串优化限定大小时），所以当rehash的时候，新生成的string只需要move由来的string就可以了。下图展示了其内存布局：</p>
<p><img loading="lazy" src="/img/phmap/flat_map_string_nonesso.png" alt=""  />
</p>
<p><strong>另外，如果提前知道需要插入的pair的数量（或者大致数量），特别是只作为一个look-up table使用时（一次性插入，只查询或更改已存在的key），那么使用提前 <code>reverse</code>是个明智的选择，这能有效提高哈希表的性能。一般需要reserve成需要插入数量的 <em>两倍</em> 而不是一倍 ，因为与vector这样的容器不同的是，为了防止过于频繁的碰撞，会在每个bucket还没满的时候就进行扩容</strong></p>
<h3 id="parallel_flat_hash_map">parallel_flat_hash_map</h3>
<p><code>phmap</code>库除了包含继承自 <code>abseil</code>的 <code>{flat/node}_hash_{set/map}</code>外，还有支持并发操作下的 <code>parallel_*</code>系列。以 <code>parallel_flat_hash_map</code>为例，其实现如下图：</p>
<p><img loading="lazy" src="/img/phmap/parallel_hash_map.png" alt=""  />
</p>
<p>一个 <code>parallel_flat_hash_map</code>有（默认 2^4 = ）16 个 <code>子flat_hash_map</code>组成。这样做可以</p>
<ol>
<li>更加细粒度的使用锁，从而减少锁之间的等待</li>
<li>一次rehash一个 <code>submap</code>，减小修改操作的开销</li>
</ol>
<p>基本的使用方法也很简单，需要在模板参数上指定一个锁，一般使用（std::mutex或者std::shared_mutex，官方文档说shared_mutex性能更优，我个人的测试下mutex性能更优，但是相差不大）。其余的使用上与非parallel版本基本一致，以下是简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 前两个模板参数是key, value，最后两个模板参数是 N (2^N表示子map的数量， N默认为4)， 和指定的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>phmap<span style="color:#f92672">::</span>parallel_flat_hash_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>,
</span></span><span style="display:flex;"><span>phmap<span style="color:#f92672">::</span>priv<span style="color:#f92672">::</span>hash_default_hash<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>phmap<span style="color:#f92672">::</span>priv<span style="color:#f92672">::</span>hash_default_eq<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>phmap<span style="color:#f92672">::</span>priv<span style="color:#f92672">::</span>Allocator<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>constint, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>, <span style="color:#ae81ff">4</span>, std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>para_mp;
</span></span><span style="display:flex;"><span>para_mp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>para_mp.subcnt(); <span style="color:#75715e">// return sub map count
</span></span></span></code></pre></div><p>经过测试，在插入和修改操作混合的情况下（随机插入1000000个数，非重复数字在600000以上），<code>parallel_mp</code>耗时 <code>80ms </code>左右，而手动给 <code>flat_hash_map </code>加锁耗时 <code>250ms</code>左右。</p>
<p><strong>另外</strong>，既然 <code>parallel_*</code>是由多个子map形成，那个在特定条件下，我们甚至可以无需锁就能保证线程安全。</p>
<p>具体操作如下：</p>
<ol>
<li>已知所有的需要插入的key</li>
<li>每个线程需要有一个线程idx标识，线程数量少于 <code>子map</code>数量</li>
<li>对于特定的key，得到hashval后将这个key的所有相关操作绑定到某个特定线程上进行。</li>
</ol>
<p>这样就可以实现无锁并发</p>
<p>我们可以通过下面这个例子具体观察：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> K, <span style="color:#66d9ef">typename</span> V<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> para_mp <span style="color:#f92672">=</span> parallel_flat_hash_map<span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> keys <span style="color:#f92672">=</span> random_vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>, n);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int64_t</span> num_threads <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> thread_fn <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>num_threads](para_mp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> mp, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> keys,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> thread_idx) {
</span></span><span style="display:flex;"><span>	size_t modulo <span style="color:#f92672">=</span> mp.subcnt() <span style="color:#f92672">/</span> num_threads;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int64_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span>keys.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> keys[i];
</span></span><span style="display:flex;"><span>		size_t hashval <span style="color:#f92672">=</span> mp.hash(key);
</span></span><span style="display:flex;"><span>		size_t idx <span style="color:#f92672">=</span> mp.subidx(hashval);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">/</span> modulo <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>				thread_idx)  <span style="color:#75715e">// if the submap is suitable for this thread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		{
</span></span><span style="display:flex;"><span>			mp[key] <span style="color:#f92672">=</span> rng();  <span style="color:#75715e">// insert random value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&gt;</span> threads[num_threads];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num_threads; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>	threads[i].reset(
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">new</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>(thread_fn, std<span style="color:#f92672">::</span>ref(mp), std<span style="color:#f92672">::</span>cref(keys), i));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>timer.reset();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int64_t</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num_threads; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>threads[i]<span style="color:#f92672">-&gt;</span>join();
</span></span></code></pre></div><p>上面的代码基本展示了无锁使用 <code>parallel_*</code>的过程，我们会将hashval按照 submap 进行区分，如果 <code>idx = mp.subidx(hashval)</code> 表示这个key对应的 submap。在上述代码中，一个线程对应两个 submap可以进行插入。</p>
<p>这种用法的局限性也很明显：线程数量需要是 submap 数量的倍数；一个线程一定要对应一个下标传入需要处理的函数；总之不是很好用&hellip;</p>
<p>（在多线程下只用map更加有效的方法或许是对于不同的key直接用不同的线程进行处理，且提前reserve防止rehash的时候迭代器失效）</p>
<h3 id="benchmarks">benchmarks</h3>
<p>以下操作的个数都为 <code>1'000'000</code>次，最后一列string-&gt;string 插入次数为 <code>100'000</code>次</p>
<p><em>vector作为baseline插入pair&lt;K,V&gt;进行比较</em></p>
<table>
<thead>
<tr>
<th>benchmarks(insert)</th>
<th>insert ints</th>
<th>insert ints(reserve first)</th>
<th>insert string(sso)-&gt;ptr</th>
<th>insert int-&gt;LargeData</th>
<th>insert string(8)-&gt;string(4096)</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::vector</td>
<td>17ms</td>
<td>7ms</td>
<td>33ms</td>
<td>102ms</td>
<td>153ms</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>170ms</td>
<td>72ms</td>
<td>343ms</td>
<td>249ms</td>
<td>213ms</td>
</tr>
<tr>
<td>flat_hash_map</td>
<td>47ms</td>
<td>34ms</td>
<td>90ms</td>
<td>462ms</td>
<td>182ms</td>
</tr>
<tr>
<td>node_hash_map</td>
<td>152ms</td>
<td>68ms</td>
<td>182ms</td>
<td>236ms</td>
<td>183ms</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>benchmarks(read)</th>
<th>iterate ints</th>
<th>find int</th>
<th>iterate string</th>
<th>find string</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::vector</td>
<td>0ms</td>
<td>*</td>
<td>3ms</td>
<td>*</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>20ms</td>
<td>52ms</td>
<td>55ms</td>
<td>152ms</td>
</tr>
<tr>
<td>flat_hash_map</td>
<td>3ms</td>
<td>23ms</td>
<td>8ms</td>
<td>71ms</td>
</tr>
<tr>
<td>node_hash_map</td>
<td>14ms</td>
<td>38ms</td>
<td>14ms</td>
<td>108ms</td>
</tr>
</tbody>
</table>
<p><em>About parallel_flat_hash_map</em></p>
<table>
<thead>
<tr>
<th>inserting 1000000 ints</th>
<th>1-thread</th>
<th>8-threads</th>
<th>8-threads</th>
</tr>
</thead>
<tbody>
<tr>
<td>flat_hash_map</td>
<td>31ms</td>
<td>23ms(no lock)</td>
<td>214ms(mutex manually)</td>
</tr>
<tr>
<td>parallel_flat_hash_map</td>
<td>35ms</td>
<td>*</td>
<td>70ms(mutex/shared_mutex)</td>
</tr>
</tbody>
</table>
<h3 id="一个小问题">一个小问题</h3>
<p>在测试的时候发现，无论是 <code>flat_hash_map</code>还是 <code>node_hash_map</code>都没法插入 <code>None-moveable</code>的数据，但是 <code>std::unordered_map</code>可以。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>structNonCopy {
</span></span><span style="display:flex;"><span>	NonCopy() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>	NonCopy(NonCopyconst<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>	NonCopy<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(NonCopyconst<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>	NonCopy<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(NonCopy<span style="color:#f92672">&amp;&amp;</span> rhs) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>	NonCopy(NonCopy<span style="color:#f92672">&amp;&amp;</span> rhs) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>structNonMove {
</span></span><span style="display:flex;"><span>	NonMove() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>	NonMove(NonMoveconst<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>	NonMove<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(NonMoveconst<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>	NonMove(NonMove<span style="color:#f92672">&amp;&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>	NonMove<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(NonMove<span style="color:#f92672">&amp;&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> fmp <span style="color:#f92672">=</span> flat_hash_map<span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> nodemp <span style="color:#f92672">=</span> node_hash_map<span style="color:#f92672">&lt;</span>K, V<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TEST_CASE(<span style="color:#e6db74">&#34;hash_map&#34;</span>) {
</span></span><span style="display:flex;"><span>	fmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, NonCopy<span style="color:#f92672">&gt;</span> mp_nocp;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, NonCopy<span style="color:#f92672">&gt;</span> stdmp_nocp;
</span></span><span style="display:flex;"><span>	nodemp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, NonCopy<span style="color:#f92672">&gt;</span> nodemp_nocp;
</span></span><span style="display:flex;"><span>	fmp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, tbs<span style="color:#f92672">::</span>NonMove<span style="color:#f92672">&gt;</span> mp_nomv;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, NonMove<span style="color:#f92672">&gt;</span> stdmp_nomv;
</span></span><span style="display:flex;"><span>	nodemp<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, NonMove<span style="color:#f92672">&gt;</span> nodemp_nomv;
</span></span><span style="display:flex;"><span>	constint n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		stdmp_nocp[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(NonCopy());
</span></span><span style="display:flex;"><span>    mp_nocp[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(NonCopy());
</span></span><span style="display:flex;"><span>    node_nocp[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(NonCopy());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    stdmp_nomv.emplace(i, NonMove());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// the following code can&#39;t pass complile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// for (int i = 0; i &lt; n; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   nodemp_nomv.emplace(i, NonMove());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// for (int i = 0; i &lt; n; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   mp_nomv.emplace(i, NonMove());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>如果说 <code>flat_hash_map</code>在 rehash的时候需要move所以禁止使用NoneMoveable还可以理解，但是 <code>node_hash_map</code>的行为应该和 <code>unordered_map</code>是一致，还是有这个问题。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>将Wavelet Tree用于算法竞赛</title>
      <link>https://caaatch22.github.io/posts/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84wavelet-tree/</link>
      <pubDate>Tue, 10 Jan 2023 16:18:32 +0000</pubDate>
      
      <guid>https://caaatch22.github.io/posts/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84wavelet-tree/</guid>
      <description>Wavelet Tree for Competitive Programming 最近在学FM-Index相关算法用于数据库，了解到Wavelet Tree这一数据结构，发现其还可以应用在算法竞赛中。网上相关中文资料比较少，权当自己做个学习笔记
开始之前 在学习wavelet tree前，不妨看看他能解决什么样的问题。
假设我们有一长为 $n$ 的序列 $A[0&amp;hellip;n - 1]$ 。在算法竞赛中，典型的数据量是 $n = 1e5, |A[i]| &amp;lt;= 1e9$
区间 $[L, R)$ 中元素$x$的出现次数 区间 $[L, R)$ 中的第k小数 区间 $[L, R)$ 上 小于等于x的数的个数 &amp;hellip; 以上问题都可以通过可持久化线段树在解决。那为什么还需要wavelet tree呢，我们都知道可持久化线段树的常数很大，并且十分消耗空间，在有些苛刻的题目下可能会被卡 好吧应该都是金牌题，不是我该考虑的 。利用wavelet tree可以在$log(\sigma)$时间内完成的同时（且优秀的常数），若使用bitvector优化空间，空间上大概比可持久化线段树少一个量级。最重要的一点是，我个人觉得他比主席树更加直观易懂。 $\sigma$ = | $\Sigma = {1, 2, \cdots, \sigma}$| （用于序列上时是值域大小）。
用wavelet tree的缺点就是带修改操作比较难写，码量较大，一般不会在比赛时使用。
Wavelet Tree 该图给出了用序列 $A = [7, 3, 5, 6, 1, 3, 2, 7, 8, 4]$ 构建的wavelet tree的形态。对于树上的每个节点，我们会将其按照值域分成两个部分$[low, mid), [mid, high)$。通过 稳定划分（stable_partition，即不改变相对顺序的情况下划分）将该节点上的序列中小于 $mid$的划分到左子树中，大于等于mid的划分到右子树中，递归直至节点中只有一种值时为叶节点。需要注意的是，我们并不会在叶子节点中直接存储序列的值，而是通过某个方法使得我们能够使用较小的空间的情况下得到足够的信息。</description>
      <content:encoded><![CDATA[<h1 id="wavelet-tree-for-competitive-programming">Wavelet Tree for Competitive Programming</h1>
<blockquote>
<p>最近在学<em>FM-Index</em>相关算法用于数据库，了解到Wavelet Tree这一数据结构，发现其还可以应用在算法竞赛中。网上相关中文资料比较少，权当自己做个学习笔记</p>
</blockquote>
<h2 id="开始之前">开始之前</h2>
<p>在学习<code>wavelet tree</code>前，不妨看看他能解决什么样的问题。</p>
<p>假设我们有一长为 $n$ 的序列 $A[0&hellip;n - 1]$ 。在算法竞赛中，典型的数据量是  $n = 1e5,  |A[i]| &lt;= 1e9$</p>
<ul>
<li>区间 $[L, R)$ 中元素$x$的<code>出现次数</code></li>
<li>区间 $[L, R)$ 中的<code>第k小数</code></li>
<li>区间 $[L, R)$ 上 <code>小于等于x的数的个数</code></li>
<li>&hellip;</li>
</ul>
<p>以上问题都可以通过<em>可持久化线段树</em>在解决。那为什么还需要wavelet tree呢，我们都知道可持久化线段树的常数很大，并且十分消耗空间，在有些苛刻的题目下可能会被卡  <del>好吧应该都是金牌题，不是我该考虑的</del> 。利用wavelet tree可以在$log(\sigma)$时间内完成的同时（且优秀的常数），若使用<code>bitvector</code>优化空间，空间上大概比可持久化线段树少一个量级。最重要的一点是，我个人觉得他比主席树更加直观易懂。
$\sigma$ = | $\Sigma = {1, 2, \cdots, \sigma}$| （用于序列上时是值域大小）。</p>
<blockquote>
<p>用wavelet tree的缺点就是带修改操作比较难写，码量较大，一般不会在比赛时使用。</p>
</blockquote>
<h2 id="wavelet-tree">Wavelet Tree</h2>
<p><img loading="lazy" src="/img/waveletTree/waveletTree.png" alt=""  />
</p>
<p>该图给出了用序列 $A = [7, 3, 5, 6, 1, 3, 2, 7, 8, 4]$ 构建的wavelet tree的形态。对于树上的每个节点，我们会将其按照值域分成两个部分$[low, mid), [mid, high)$。通过 <strong>稳定划分</strong>（stable_partition，即不改变相对顺序的情况下划分）将该节点上的序列中小于 $mid$的划分到左子树中，大于等于mid的划分到右子树中，递归直至节点中只有一种值时为叶节点。需要注意的是，我们并不会在叶子节点中直接存储序列的值，而是通过某个方法使得我们能够使用较小的空间的情况下得到足够的信息。</p>
<p>设根节点编号为 $u = 1$ ，其左子树的根节点为 $2 * u$ , 右子树的根节点为 $2 * u + 1$ ，以此类推。每个节点都对应一对左闭右开的区间 $[lo, hi)$，表示该节点中数值的值域范围。同时有一个 $mid = \lfloor \frac{lo + hi}{2} \rfloor$ ，表示该节点左右子树分裂标准，即左子树中值域范围是 $[lo, mid)$ , 右子树 $[mid, hi)$ 。</p>
<p>在wavelet tree中，我们实际上在维护一个二维数组<code>vector&lt;vector&lt;int&gt;&gt; c</code>，我们不妨叫他<strong>前缀计数数组</strong>，其中 <strong><code>c[u][i]</code>表示的是u结点中下标为[0, i)中的数有多少个小于该节点对应的mid</strong>。另外，若$u$结点中有$n$个数，那么<code>c[u].size() = n + 1</code>， 我们另<code>c[u][0] = 0</code>。例如，下图给出了部分结点对应的 <code>c[u][i]</code>数组
<img loading="lazy" src="/img/waveletTree/Counting-array.png" alt=""  />
</p>
<p>现在，我们来看如何用这个构建好的前缀计数数组完成以下的查询问题：</p>
<h3 id="rankint-val-int-pos">rank(int val, int pos)</h3>
<p>该函数返回区间 $[0, pos)$ 中值为$val$的数的个数（我也不知道为什么叫rank。。。或许这个名称是由bitvector中继承而来？）。有了这个函数，我们就容易得到区间 $[i, j)$ 内某个数的出现次数，就是 $rank(val, j) - rank(val, i)$</p>
<p>设 $rank_u (val, pos)$ 为结点$u$中值为val的数在 $[0, pos)$ 中的出现次数（ $pos &lt;= size(u)$ ）$mid$为节点$u$分裂标准，我们可以得到：</p>
<ul>
<li>若 $val &lt; mid$，则 $rank_u(val, pos) = rank_{LeftChild(u)}(val, c[u][pos])$</li>
<li>若 $val &gt;= mid$,  $rank_u(val, pos) = rank_{RightChild(u)}(val, pos - c[u][pos])$</li>
</ul>
<p>如何理解上述变化呢，其实也很简单，就是要理解<code>c[u][i]</code>的意义，它同时也表示将u结点中下标为i的点映射到子结点中后他的位置。而映射规则为<strong>若这个数小于mid，则将其映射到左儿子的c[u][i]处；若这个数大于等于mid，则将其映射到右儿子的i-c[u][i]处</strong> 不理解的可再仔细想想<code>c[u][i]</code>的这两个解释之间的等价性。</p>
<p>有了上述说明，我们就容易递归的完成$rank$操作。例如，假设我们需要得到 $rank_1(val = 3, pos = 7)$
-由于 $3&lt;mid，c[1][7] = 4$, 则递归左子树 $rank_2(3, 4)$；</p>
<ul>
<li>左子树中，$3 &gt;= (mid = 2), 4-c[2][4] = 3$，递归到右子树 $rank_5(3, 3)$</li>
<li>右子树中，$3 &gt;= (mid = 3), 3-c[5][3] = 2$，递归到右子树</li>
<li>右子树为叶子节点，则此时结点内的树的个数（即为上一步中 $3-c[5][3] = 2$）为$val$的个数</li>
</ul>
<h3 id="quantileint-k-int-l-int-r">quantile(int k, int l, int r)</h3>
<p>该函数返回区间 $[l, r)$间的第k小数（最小的为第一小）。我们知道，<code>c[u][l]</code>表示下标为结点 $u$中有多少个下标在 $[0， l)$中的数被映射到了左子树。那么，</p>
<ul>
<li>若<code>c[u][r] - c[u][l] &gt;= k</code>，则区间 $[l, r)$内第k小即为左子树中的第k小。</li>
<li>若<code>c[u][r] - c[u][l] &lt; k</code>，则区间 $[l, r)$内第k小即为右子树中的第<code>k - (c[u][r] - c[u][l])</code>小。</li>
</ul>
<p>从而我们可以递归的进行求解。</p>
<h3 id="c数组的构建">c数组的构建</h3>
<p>实际上上面已经讲的差不多了，直接看代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 参数都是该结点对应序列相关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// u: 该结点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// begin， end: 该结点对应序列的首个，末尾迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// lo, hi： 该结点对应值域为 [lo, hi)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(iter begin, iter end, <span style="color:#66d9ef">int</span> lo, <span style="color:#66d9ef">int</span> hi, <span style="color:#66d9ef">int</span> u) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (lo <span style="color:#f92672">+</span> hi) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    c[u].reserve(end <span style="color:#f92672">-</span> begin <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// reverse只分配空间不进行构造，所以后面还可以push_back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    c[u].push_back(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> begin; it <span style="color:#f92672">!=</span> end; <span style="color:#f92672">++</span>it) {
</span></span><span style="display:flex;"><span>        c[u].push_back(c[u].back() <span style="color:#f92672">+</span> (<span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;</span> m));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 稳定划分，将[begin, end)间的小于m的值划分到前半部分，pivot为后半部分首个迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> pivot <span style="color:#f92672">=</span> stable_partition(begin, end, [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> i){<span style="color:#66d9ef">return</span> i <span style="color:#f92672">&lt;</span> m};);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    build(begin, pivot, lo, m, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> u);
</span></span><span style="display:flex;"><span>    build(pivot, end, m, hi, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> u <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>到这个，我们已经可以利用没有进行空间优化的wavelet tree轻松切掉这道 <a href="https://www.luogu.com.cn/problem/P3834">可持久化线段树的模板题</a>了，代码如下</p>
<h2 id="模板">模板</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">WaveletTree</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> iter <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> SIGMA;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WaveletTree(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a, <span style="color:#66d9ef">int</span> sigma)<span style="color:#f92672">:</span> c(sigma<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>), SIGMA(sigma) {
</span></span><span style="display:flex;"><span>        build(a.begin(), a.end(), <span style="color:#ae81ff">0</span>, SIGMA, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(iter begin, iter end, <span style="color:#66d9ef">int</span> lo, <span style="color:#66d9ef">int</span> hi, <span style="color:#66d9ef">int</span> u) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (lo <span style="color:#f92672">+</span> hi) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        c[u].reserve(end <span style="color:#f92672">-</span> begin <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        c[u].push_back(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> begin; it <span style="color:#f92672">!=</span> end; <span style="color:#f92672">++</span>it) {
</span></span><span style="display:flex;"><span>            c[u].push_back(c[u].back() <span style="color:#f92672">+</span> (<span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;</span> m));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> stable_partition(begin, end, [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> i)
</span></span><span style="display:flex;"><span>                                  { <span style="color:#66d9ef">return</span> i <span style="color:#f92672">&lt;</span> m; });
</span></span><span style="display:flex;"><span>        build(begin, p, lo, m, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> u);
</span></span><span style="display:flex;"><span>        build(p, end, m, hi, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> u <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// occurrences of val in position[0, i)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rank</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> i) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(val <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> or val <span style="color:#f92672">&gt;=</span> SIGMA) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, hi <span style="color:#f92672">=</span> SIGMA, u <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (lo <span style="color:#f92672">+</span> hi) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(val <span style="color:#f92672">&lt;</span> m) {
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">=</span> c[u][i], hi <span style="color:#f92672">=</span> m;
</span></span><span style="display:flex;"><span>                u <span style="color:#f92672">=</span> u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">-=</span> c[u][i], lo <span style="color:#f92672">=</span> m;
</span></span><span style="display:flex;"><span>                u <span style="color:#f92672">=</span> u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get kth smallest number in [l, r)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">quantile</span>(<span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// assert(k &gt; 0 &amp;&amp; k &lt;= j - i);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, hi <span style="color:#f92672">=</span> SIGMA, u <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (lo <span style="color:#f92672">+</span> hi) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> nl <span style="color:#f92672">=</span> c[u][l], nr <span style="color:#f92672">=</span> c[u][r];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(k <span style="color:#f92672">&lt;=</span> nr <span style="color:#f92672">-</span> nl) {
</span></span><span style="display:flex;"><span>                r <span style="color:#f92672">=</span> nr, l <span style="color:#f92672">=</span> nl, hi <span style="color:#f92672">=</span> m;
</span></span><span style="display:flex;"><span>                u <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> u;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                k <span style="color:#f92672">-=</span> nr <span style="color:#f92672">-</span> nl;
</span></span><span style="display:flex;"><span>                r <span style="color:#f92672">-=</span> nr, l <span style="color:#f92672">-=</span> nl, lo <span style="color:#f92672">=</span> m;
</span></span><span style="display:flex;"><span>                u <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> u <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> lo;   
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    cin.tie(<span style="color:#66d9ef">nullptr</span>); cout.tie(<span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, q;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x : a) {
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    WaveletTree wt(a, <span style="color:#f92672">*</span>max_element(a.begin(), a.end()) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(q <span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k, l, r;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> l <span style="color:#f92672">&gt;&gt;</span> r <span style="color:#f92672">&gt;&gt;</span> k;
</span></span><span style="display:flex;"><span>        l<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> wt.quantile(k, l, r) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
